<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://pdfmake.org"

    >pdfmake (v0.1.27)</a>
</h1>
<h4>Client/server side PDF printing in pure JavaScript</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake">module pdfmake</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pdfmake">
            function <span class="apidocSignatureSpan"></span>pdfmake
            <span class="apidocSignatureSpan">(fontDescriptors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure">
            function <span class="apidocSignatureSpan">pdfmake.</span>docMeasure
            <span class="apidocSignatureSpan">(fontProvider, styleDictionary, defaultStyle, imageMeasure, tableLayouts, images)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext">
            function <span class="apidocSignatureSpan">pdfmake.</span>documentContext
            <span class="apidocSignatureSpan">(pageSize, pageMargins)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.elementWriter">
            function <span class="apidocSignatureSpan">pdfmake.</span>elementWriter
            <span class="apidocSignatureSpan">(context, tracker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.fontProvider">
            function <span class="apidocSignatureSpan">pdfmake.</span>fontProvider
            <span class="apidocSignatureSpan">(fontDescriptors, pdfKitDoc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.imageMeasure">
            function <span class="apidocSignatureSpan">pdfmake.</span>imageMeasure
            <span class="apidocSignatureSpan">(pdfKitDoc, imageDictionary)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder">
            function <span class="apidocSignatureSpan">pdfmake.</span>layoutBuilder
            <span class="apidocSignatureSpan">(pageSize, pageMargins, imageMeasure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.line">
            function <span class="apidocSignatureSpan">pdfmake.</span>line
            <span class="apidocSignatureSpan">(maxWidth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pageElementWriter">
            function <span class="apidocSignatureSpan">pdfmake.</span>pageElementWriter
            <span class="apidocSignatureSpan">(context, tracker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.styleContextStack">
            function <span class="apidocSignatureSpan">pdfmake.</span>styleContextStack
            <span class="apidocSignatureSpan">(styleDictionary, defaultStyle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.tableProcessor">
            function <span class="apidocSignatureSpan">pdfmake.</span>tableProcessor
            <span class="apidocSignatureSpan">(tableNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.textTools">
            function <span class="apidocSignatureSpan">pdfmake.</span>textTools
            <span class="apidocSignatureSpan">(fontProvider)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.traversalTracker">
            function <span class="apidocSignatureSpan">pdfmake.</span>traversalTracker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>columnCalculator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>docMeasure.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>documentContext.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>elementWriter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>fontProvider.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>imageMeasure.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>layoutBuilder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>line.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>pageElementWriter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>pdfMake</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>qrEnc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>styleContextStack.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>tableProcessor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>textDecorator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>textTools.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdfmake.</span>traversalTracker.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.columnCalculator">module pdfmake.columnCalculator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.columnCalculator.buildColumnWidths">
            function <span class="apidocSignatureSpan">pdfmake.columnCalculator.</span>buildColumnWidths
            <span class="apidocSignatureSpan">(columns, availableWidth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.columnCalculator.isAutoColumn">
            function <span class="apidocSignatureSpan">pdfmake.columnCalculator.</span>isAutoColumn
            <span class="apidocSignatureSpan">(column)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.columnCalculator.isStarColumn">
            function <span class="apidocSignatureSpan">pdfmake.columnCalculator.</span>isStarColumn
            <span class="apidocSignatureSpan">(column)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.columnCalculator.measureMinMax">
            function <span class="apidocSignatureSpan">pdfmake.columnCalculator.</span>measureMinMax
            <span class="apidocSignatureSpan">(columns)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.docMeasure">module pdfmake.docMeasure</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.docMeasure">
            function <span class="apidocSignatureSpan">pdfmake.</span>docMeasure
            <span class="apidocSignatureSpan">(fontProvider, styleDictionary, defaultStyle, imageMeasure, tableLayouts, images)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.docMeasure.prototype">module pdfmake.docMeasure.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.buildOrderedMarker">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>buildOrderedMarker
            <span class="apidocSignatureSpan">(counter, styleStack, type, separator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.buildUnorderedMarker">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>buildUnorderedMarker
            <span class="apidocSignatureSpan">(styleStack, gapSize, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.convertIfBase64Image">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>convertIfBase64Image
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.gapSizeForList">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>gapSizeForList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.measureCanvas">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureCanvas
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.measureColumns">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureColumns
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.measureDocument">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureDocument
            <span class="apidocSignatureSpan">(docStructure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.measureImage">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureImage
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.measureLeaf">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureLeaf
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.measureNode">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.measureOrderedList">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureOrderedList
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.measureQr">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureQr
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.measureTable">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureTable
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.measureUnorderedList">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureUnorderedList
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.docMeasure.prototype.measureVerticalContainer">
            function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureVerticalContainer
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.documentContext">module pdfmake.documentContext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.documentContext">
            function <span class="apidocSignatureSpan">pdfmake.</span>documentContext
            <span class="apidocSignatureSpan">(pageSize, pageMargins)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.documentContext.prototype">module pdfmake.documentContext.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.addMargin">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>addMargin
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.addPage">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>addPage
            <span class="apidocSignatureSpan">(pageSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.beginColumn">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>beginColumn
            <span class="apidocSignatureSpan">(width, offset, endingCell)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.beginColumnGroup">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>beginColumnGroup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.beginDetachedBlock">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>beginDetachedBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.calculateBottomMost">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>calculateBottomMost
            <span class="apidocSignatureSpan">(destContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.completeColumnGroup">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>completeColumnGroup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.endDetachedBlock">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>endDetachedBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.getCurrentPage">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>getCurrentPage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.getCurrentPosition">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>getCurrentPosition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.initializePage">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>initializePage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.markEnding">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>markEnding
            <span class="apidocSignatureSpan">(endingCell)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.moveDown">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>moveDown
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.moveTo">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>moveTo
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.moveToNextPage">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>moveToNextPage
            <span class="apidocSignatureSpan">(pageOrientation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.pageSnapshot">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>pageSnapshot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.documentContext.prototype.saveContextInEndingCell">
            function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>saveContextInEndingCell
            <span class="apidocSignatureSpan">(endingCell)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.elementWriter">module pdfmake.elementWriter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.elementWriter.elementWriter">
            function <span class="apidocSignatureSpan">pdfmake.</span>elementWriter
            <span class="apidocSignatureSpan">(context, tracker)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.elementWriter.prototype">module pdfmake.elementWriter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.elementWriter.prototype.addFragment">
            function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>addFragment
            <span class="apidocSignatureSpan">(block, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.elementWriter.prototype.addImage">
            function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>addImage
            <span class="apidocSignatureSpan">(image, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.elementWriter.prototype.addLine">
            function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>addLine
            <span class="apidocSignatureSpan">(line, dontUpdateContextPosition, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.elementWriter.prototype.addQr">
            function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>addQr
            <span class="apidocSignatureSpan">(qr, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.elementWriter.prototype.addVector">
            function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>addVector
            <span class="apidocSignatureSpan">(vector, ignoreContextX, ignoreContextY, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.elementWriter.prototype.alignImage">
            function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>alignImage
            <span class="apidocSignatureSpan">(image)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.elementWriter.prototype.alignLine">
            function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>alignLine
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.elementWriter.prototype.getCurrentPositionOnPage">
            function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>getCurrentPositionOnPage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.elementWriter.prototype.popContext">
            function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>popContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.elementWriter.prototype.pushContext">
            function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>pushContext
            <span class="apidocSignatureSpan">(contextOrWidth, height)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.fontProvider">module pdfmake.fontProvider</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.fontProvider.fontProvider">
            function <span class="apidocSignatureSpan">pdfmake.</span>fontProvider
            <span class="apidocSignatureSpan">(fontDescriptors, pdfKitDoc)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.fontProvider.prototype">module pdfmake.fontProvider.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.fontProvider.prototype.provideFont">
            function <span class="apidocSignatureSpan">pdfmake.fontProvider.prototype.</span>provideFont
            <span class="apidocSignatureSpan">(familyName, bold, italics)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.helpers">module pdfmake.helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.helpers.fontStringify">
            function <span class="apidocSignatureSpan">pdfmake.helpers.</span>fontStringify
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.helpers.isFunction">
            function <span class="apidocSignatureSpan">pdfmake.helpers.</span>isFunction
            <span class="apidocSignatureSpan">(functionToCheck)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.helpers.offsetVector">
            function <span class="apidocSignatureSpan">pdfmake.helpers.</span>offsetVector
            <span class="apidocSignatureSpan">(vector, x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.helpers.pack">
            function <span class="apidocSignatureSpan">pdfmake.helpers.</span>pack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.imageMeasure">module pdfmake.imageMeasure</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.imageMeasure.imageMeasure">
            function <span class="apidocSignatureSpan">pdfmake.</span>imageMeasure
            <span class="apidocSignatureSpan">(pdfKitDoc, imageDictionary)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.imageMeasure.prototype">module pdfmake.imageMeasure.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.imageMeasure.prototype.measureImage">
            function <span class="apidocSignatureSpan">pdfmake.imageMeasure.prototype.</span>measureImage
            <span class="apidocSignatureSpan">(src)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.layoutBuilder">module pdfmake.layoutBuilder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.layoutBuilder">
            function <span class="apidocSignatureSpan">pdfmake.</span>layoutBuilder
            <span class="apidocSignatureSpan">(pageSize, pageMargins, imageMeasure)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.layoutBuilder.prototype">module pdfmake.layoutBuilder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.addBackground">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>addBackground
            <span class="apidocSignatureSpan">(background)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.addDynamicRepeatable">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>addDynamicRepeatable
            <span class="apidocSignatureSpan">(nodeGetter, sizeFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.addHeadersAndFooters">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>addHeadersAndFooters
            <span class="apidocSignatureSpan">(header, footer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.addStaticRepeatable">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>addStaticRepeatable
            <span class="apidocSignatureSpan">(headerOrFooter, sizeFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.addWatermark">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>addWatermark
            <span class="apidocSignatureSpan">(watermark, fontProvider, defaultStyle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.buildNextLine">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>buildNextLine
            <span class="apidocSignatureSpan">(textNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.layoutDocument">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>layoutDocument
            <span class="apidocSignatureSpan">(docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images, watermark, pageBreakBeforeFct )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.processCanvas">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processCanvas
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.processColumns">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processColumns
            <span class="apidocSignatureSpan">(columnNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.processImage">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processImage
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.processLeaf">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processLeaf
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.processList">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processList
            <span class="apidocSignatureSpan">(orderedList, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.processNode">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.processQr">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processQr
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.processRow">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processRow
            <span class="apidocSignatureSpan">(columns, widths, gaps, tableBody, tableRow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.processTable">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processTable
            <span class="apidocSignatureSpan">(tableNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.processVerticalContainer">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processVerticalContainer
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.registerTableLayouts">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>registerTableLayouts
            <span class="apidocSignatureSpan">(tableLayouts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.layoutBuilder.prototype.tryLayoutDocument">
            function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>tryLayoutDocument
            <span class="apidocSignatureSpan">(docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images, watermark, pageBreakBeforeFct )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.line">module pdfmake.line</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.line.line">
            function <span class="apidocSignatureSpan">pdfmake.</span>line
            <span class="apidocSignatureSpan">(maxWidth)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.line.prototype">module pdfmake.line.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.line.prototype.addInline">
            function <span class="apidocSignatureSpan">pdfmake.line.prototype.</span>addInline
            <span class="apidocSignatureSpan">(inline)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.line.prototype.getAscenderHeight">
            function <span class="apidocSignatureSpan">pdfmake.line.prototype.</span>getAscenderHeight
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.line.prototype.getHeight">
            function <span class="apidocSignatureSpan">pdfmake.line.prototype.</span>getHeight
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.line.prototype.getWidth">
            function <span class="apidocSignatureSpan">pdfmake.line.prototype.</span>getWidth
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.line.prototype.hasEnoughSpaceForInline">
            function <span class="apidocSignatureSpan">pdfmake.line.prototype.</span>hasEnoughSpaceForInline
            <span class="apidocSignatureSpan">(inline)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.pageElementWriter">module pdfmake.pageElementWriter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pageElementWriter.pageElementWriter">
            function <span class="apidocSignatureSpan">pdfmake.</span>pageElementWriter
            <span class="apidocSignatureSpan">(context, tracker)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.pageElementWriter.prototype">module pdfmake.pageElementWriter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pageElementWriter.prototype.addFragment">
            function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>addFragment
            <span class="apidocSignatureSpan">(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pageElementWriter.prototype.addImage">
            function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>addImage
            <span class="apidocSignatureSpan">(image, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pageElementWriter.prototype.addLine">
            function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>addLine
            <span class="apidocSignatureSpan">(line, dontUpdateContextPosition, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pageElementWriter.prototype.addQr">
            function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>addQr
            <span class="apidocSignatureSpan">(qr, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pageElementWriter.prototype.addVector">
            function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>addVector
            <span class="apidocSignatureSpan">(vector, ignoreContextX, ignoreContextY, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pageElementWriter.prototype.beginUnbreakableBlock">
            function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>beginUnbreakableBlock
            <span class="apidocSignatureSpan">(width, height)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pageElementWriter.prototype.commitUnbreakableBlock">
            function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>commitUnbreakableBlock
            <span class="apidocSignatureSpan">(forcedX, forcedY)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pageElementWriter.prototype.context">
            function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>context
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pageElementWriter.prototype.currentBlockToRepeatable">
            function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>currentBlockToRepeatable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pageElementWriter.prototype.moveToNextPage">
            function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>moveToNextPage
            <span class="apidocSignatureSpan">(pageOrientation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pageElementWriter.prototype.popFromRepeatables">
            function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>popFromRepeatables
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pageElementWriter.prototype.pushToRepeatables">
            function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>pushToRepeatables
            <span class="apidocSignatureSpan">(rep)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.pdfMake">module pdfmake.pdfMake</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.pdfMake.createPdf">
            function <span class="apidocSignatureSpan">pdfmake.pdfMake.</span>createPdf
            <span class="apidocSignatureSpan">(docDefinition)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.qrEnc">module pdfmake.qrEnc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.qrEnc.measure">
            function <span class="apidocSignatureSpan">pdfmake.qrEnc.</span>measure
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.styleContextStack">module pdfmake.styleContextStack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.styleContextStack.styleContextStack">
            function <span class="apidocSignatureSpan">pdfmake.</span>styleContextStack
            <span class="apidocSignatureSpan">(styleDictionary, defaultStyle)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.styleContextStack.prototype">module pdfmake.styleContextStack.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.styleContextStack.prototype.auto">
            function <span class="apidocSignatureSpan">pdfmake.styleContextStack.prototype.</span>auto
            <span class="apidocSignatureSpan">(item, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.styleContextStack.prototype.autopush">
            function <span class="apidocSignatureSpan">pdfmake.styleContextStack.prototype.</span>autopush
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.styleContextStack.prototype.clone">
            function <span class="apidocSignatureSpan">pdfmake.styleContextStack.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.styleContextStack.prototype.getProperty">
            function <span class="apidocSignatureSpan">pdfmake.styleContextStack.prototype.</span>getProperty
            <span class="apidocSignatureSpan">(property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.styleContextStack.prototype.pop">
            function <span class="apidocSignatureSpan">pdfmake.styleContextStack.prototype.</span>pop
            <span class="apidocSignatureSpan">(howMany)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.styleContextStack.prototype.push">
            function <span class="apidocSignatureSpan">pdfmake.styleContextStack.prototype.</span>push
            <span class="apidocSignatureSpan">(styleNameOrOverride)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.tableProcessor">module pdfmake.tableProcessor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.tableProcessor.tableProcessor">
            function <span class="apidocSignatureSpan">pdfmake.</span>tableProcessor
            <span class="apidocSignatureSpan">(tableNode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.tableProcessor.prototype">module pdfmake.tableProcessor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.tableProcessor.prototype.beginRow">
            function <span class="apidocSignatureSpan">pdfmake.tableProcessor.prototype.</span>beginRow
            <span class="apidocSignatureSpan">(rowIndex, writer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.tableProcessor.prototype.beginTable">
            function <span class="apidocSignatureSpan">pdfmake.tableProcessor.prototype.</span>beginTable
            <span class="apidocSignatureSpan">(writer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.tableProcessor.prototype.drawHorizontalLine">
            function <span class="apidocSignatureSpan">pdfmake.tableProcessor.prototype.</span>drawHorizontalLine
            <span class="apidocSignatureSpan">(lineIndex, writer, overrideY)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.tableProcessor.prototype.drawVerticalLine">
            function <span class="apidocSignatureSpan">pdfmake.tableProcessor.prototype.</span>drawVerticalLine
            <span class="apidocSignatureSpan">(x, y0, y1, vLineIndex, writer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.tableProcessor.prototype.endRow">
            function <span class="apidocSignatureSpan">pdfmake.tableProcessor.prototype.</span>endRow
            <span class="apidocSignatureSpan">(rowIndex, writer, pageBreaks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.tableProcessor.prototype.endTable">
            function <span class="apidocSignatureSpan">pdfmake.tableProcessor.prototype.</span>endTable
            <span class="apidocSignatureSpan">(writer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.tableProcessor.prototype.onRowBreak">
            function <span class="apidocSignatureSpan">pdfmake.tableProcessor.prototype.</span>onRowBreak
            <span class="apidocSignatureSpan">(rowIndex, writer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.textDecorator">module pdfmake.textDecorator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.textDecorator.drawBackground">
            function <span class="apidocSignatureSpan">pdfmake.textDecorator.</span>drawBackground
            <span class="apidocSignatureSpan">(line, x, y, pdfKitDoc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.textDecorator.drawDecorations">
            function <span class="apidocSignatureSpan">pdfmake.textDecorator.</span>drawDecorations
            <span class="apidocSignatureSpan">(line, x, y, pdfKitDoc)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.textTools">module pdfmake.textTools</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.textTools.textTools">
            function <span class="apidocSignatureSpan">pdfmake.</span>textTools
            <span class="apidocSignatureSpan">(fontProvider)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.textTools.prototype">module pdfmake.textTools.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.textTools.prototype.buildInlines">
            function <span class="apidocSignatureSpan">pdfmake.textTools.prototype.</span>buildInlines
            <span class="apidocSignatureSpan">(textArray, styleContextStack)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.textTools.prototype.sizeOfString">
            function <span class="apidocSignatureSpan">pdfmake.textTools.prototype.</span>sizeOfString
            <span class="apidocSignatureSpan">(text, styleContextStack)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.traversalTracker">module pdfmake.traversalTracker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.traversalTracker.traversalTracker">
            function <span class="apidocSignatureSpan">pdfmake.</span>traversalTracker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdfmake.traversalTracker.prototype">module pdfmake.traversalTracker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.traversalTracker.prototype.auto">
            function <span class="apidocSignatureSpan">pdfmake.traversalTracker.prototype.</span>auto
            <span class="apidocSignatureSpan">(event, cb, innerBlock)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.traversalTracker.prototype.emit">
            function <span class="apidocSignatureSpan">pdfmake.traversalTracker.prototype.</span>emit
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.traversalTracker.prototype.startTracking">
            function <span class="apidocSignatureSpan">pdfmake.traversalTracker.prototype.</span>startTracking
            <span class="apidocSignatureSpan">(event, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdfmake.traversalTracker.prototype.stopTracking">
            function <span class="apidocSignatureSpan">pdfmake.traversalTracker.prototype.</span>stopTracking
            <span class="apidocSignatureSpan">(event, cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake" id="apidoc.module.pdfmake">module pdfmake</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.pdfmake" id="apidoc.element.pdfmake.pdfmake">
        function <span class="apidocSignatureSpan"></span>pdfmake
        <span class="apidocSignatureSpan">(fontDescriptors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PdfPrinter(fontDescriptors) {
	this.fontDescriptors = fontDescriptors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure" id="apidoc.element.pdfmake.docMeasure">
        function <span class="apidocSignatureSpan">pdfmake.</span>docMeasure
        <span class="apidocSignatureSpan">(fontProvider, styleDictionary, defaultStyle, imageMeasure, tableLayouts, images)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DocMeasure(fontProvider, styleDictionary, defaultStyle, imageMeasure, tableLayouts, images) {
	this.textTools = new TextTools(fontProvider);
	this.styleStack = new StyleContextStack(styleDictionary, defaultStyle);
	this.imageMeasure = imageMeasure;
	this.tableLayouts = tableLayouts;
	this.images = images;
	this.autoImageIndex = 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext" id="apidoc.element.pdfmake.documentContext">
        function <span class="apidocSignatureSpan">pdfmake.</span>documentContext
        <span class="apidocSignatureSpan">(pageSize, pageMargins)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DocumentContext(pageSize, pageMargins) {
	this.pages = [];

	this.pageMargins = pageMargins;

	this.x = pageMargins.left;
	this.availableWidth = pageSize.width - pageMargins.left - pageMargins.right;
	this.availableHeight = 0;
	this.page = -1;

	this.snapshots = [];

	this.endingCell = null;

	this.tracker = new TraversalTracker();

	this.addPage(pageSize);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.elementWriter" id="apidoc.element.pdfmake.elementWriter">
        function <span class="apidocSignatureSpan">pdfmake.</span>elementWriter
        <span class="apidocSignatureSpan">(context, tracker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ElementWriter(context, tracker) {
	this.context = context;
	this.contextStack = [];
	this.tracker = tracker;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.fontProvider" id="apidoc.element.pdfmake.fontProvider">
        function <span class="apidocSignatureSpan">pdfmake.</span>fontProvider
        <span class="apidocSignatureSpan">(fontDescriptors, pdfKitDoc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FontProvider(fontDescriptors, pdfKitDoc) {
	this.fonts = {};
	this.pdfKitDoc = pdfKitDoc;
	this.fontCache = {};

	for (var font in fontDescriptors) {
		if (fontDescriptors.hasOwnProperty(font)) {
			var fontDef = fontDescriptors[font];

			this.fonts[font] = {
				normal: fontDef.normal,
				bold: fontDef.bold,
				italics: fontDef.italics,
				bolditalics: fontDef.bolditalics
			};
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.imageMeasure" id="apidoc.element.pdfmake.imageMeasure">
        function <span class="apidocSignatureSpan">pdfmake.</span>imageMeasure
        <span class="apidocSignatureSpan">(pdfKitDoc, imageDictionary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ImageMeasure(pdfKitDoc, imageDictionary) {
	this.pdfKitDoc = pdfKitDoc;
	this.imageDictionary = imageDictionary || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder" id="apidoc.element.pdfmake.layoutBuilder">
        function <span class="apidocSignatureSpan">pdfmake.</span>layoutBuilder
        <span class="apidocSignatureSpan">(pageSize, pageMargins, imageMeasure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LayoutBuilder(pageSize, pageMargins, imageMeasure) {
	this.pageSize = pageSize;
	this.pageMargins = pageMargins;
	this.tracker = new TraversalTracker();
	this.imageMeasure = imageMeasure;
	this.tableLayouts = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.line" id="apidoc.element.pdfmake.line">
        function <span class="apidocSignatureSpan">pdfmake.</span>line
        <span class="apidocSignatureSpan">(maxWidth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Line(maxWidth) {
	this.maxWidth = maxWidth;
	this.leadingCut = 0;
	this.trailingCut = 0;
	this.inlineWidths = 0;
	this.inlines = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.pageElementWriter" id="apidoc.element.pdfmake.pageElementWriter">
        function <span class="apidocSignatureSpan">pdfmake.</span>pageElementWriter
        <span class="apidocSignatureSpan">(context, tracker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PageElementWriter(context, tracker) {
	this.transactionLevel = 0;
	this.repeatables = [];
	this.tracker = tracker;
	this.writer = new ElementWriter(context, tracker);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.styleContextStack" id="apidoc.element.pdfmake.styleContextStack">
        function <span class="apidocSignatureSpan">pdfmake.</span>styleContextStack
        <span class="apidocSignatureSpan">(styleDictionary, defaultStyle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StyleContextStack(styleDictionary, defaultStyle) {
	this.defaultStyle = defaultStyle || {};
	this.styleDictionary = styleDictionary;
	this.styleOverrides = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.tableProcessor" id="apidoc.element.pdfmake.tableProcessor">
        function <span class="apidocSignatureSpan">pdfmake.</span>tableProcessor
        <span class="apidocSignatureSpan">(tableNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TableProcessor(tableNode) {
	this.tableNode = tableNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.textTools" id="apidoc.element.pdfmake.textTools">
        function <span class="apidocSignatureSpan">pdfmake.</span>textTools
        <span class="apidocSignatureSpan">(fontProvider)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TextTools(fontProvider) {
	this.fontProvider = fontProvider;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.traversalTracker" id="apidoc.element.pdfmake.traversalTracker">
        function <span class="apidocSignatureSpan">pdfmake.</span>traversalTracker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TraversalTracker() {
	this.events = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.columnCalculator" id="apidoc.module.pdfmake.columnCalculator">module pdfmake.columnCalculator</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.columnCalculator.buildColumnWidths" id="apidoc.element.pdfmake.columnCalculator.buildColumnWidths">
        function <span class="apidocSignatureSpan">pdfmake.columnCalculator.</span>buildColumnWidths
        <span class="apidocSignatureSpan">(columns, availableWidth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildColumnWidths(columns, availableWidth) {
	var autoColumns = [],
		autoMin = 0, autoMax = 0,
		starColumns = [],
		starMaxMin = 0,
		starMaxMax = 0,
		fixedColumns = [],
		initial_availableWidth = availableWidth;

	columns.forEach(function (column) {
		if (isAutoColumn(column)) {
			autoColumns.push(column);
			autoMin += column._minWidth;
			autoMax += column._maxWidth;
		} else if (isStarColumn(column)) {
			starColumns.push(column);
			starMaxMin = Math.max(starMaxMin, column._minWidth);
			starMaxMax = Math.max(starMaxMax, column._maxWidth);
		} else {
			fixedColumns.push(column);
		}
	});

	fixedColumns.forEach(function (col) {
		// width specified as %
		if (typeof col.width === &#x27;string&#x27; &#x26;&#x26; /\d+%/.test(col.width)) {
			col.width = parseFloat(col.width) * initial_availableWidth / 100;
		}
		if (col.width &#x3c; (col._minWidth) &#x26;&#x26; col.elasticWidth) {
			col._calcWidth = col._minWidth;
		} else {
			col._calcWidth = col.width;
		}

		availableWidth -= col._calcWidth;
	});

	// http://www.freesoft.org/CIE/RFC/1942/18.htm
	// http://www.w3.org/TR/CSS2/tables.html#width-layout
	// http://dev.w3.org/csswg/css3-tables-algorithms/Overview.src.htm
	var minW = autoMin + starMaxMin * starColumns.length;
	var maxW = autoMax + starMaxMax * starColumns.length;
	if (minW &#x3e;= availableWidth) {
		// case 1 - there&#x27;s no way to fit all columns within available width
		// that&#x27;s actually pretty bad situation with PDF as we have no horizontal scroll
		// no easy workaround (unless we decide, in the future, to split single words)
		// currently we simply use minWidths for all columns
		autoColumns.forEach(function (col) {
			col._calcWidth = col._minWidth;
		});

		starColumns.forEach(function (col) {
			col._calcWidth = starMaxMin; // starMaxMin already contains padding
		});
	} else {
		if (maxW &#x3c; availableWidth) {
			// case 2 - we can fit rest of the table within available space
			autoColumns.forEach(function (col) {
				col._calcWidth = col._maxWidth;
				availableWidth -= col._calcWidth;
			});
		} else {
			// maxW is too large, but minW fits within available width
			var W = availableWidth - minW;
			var D = maxW - minW;

			autoColumns.forEach(function (col) {
				var d = col._maxWidth - col._minWidth;
				col._calcWidth = col._minWidth + d * W / D;
				availableWidth -= col._calcWidth;
			});
		}

		if (starColumns.length &#x3e; 0) {
			var starSize = availableWidth / starColumns.length;

			starColumns.forEach(function (col) {
				col._calcWidth = starSize;
			});
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var availableWidth = this.writer.context().availableWidth;
	var gaps = gapArray(columnNode._gap);

	if (gaps) {
		availableWidth -= (gaps.length - 1) * columnNode._gap;
	}

	ColumnCalculator.<span class="apidocCodeKeywordSpan">buildColumnWidths</span>(columns, availableWidth);
	var result = this.processRow(columns, columns, gaps);
	addAll(columnNode.positions, result.positions);


	function gapArray(gap) {
		if (!gap) {
			return null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.columnCalculator.isAutoColumn" id="apidoc.element.pdfmake.columnCalculator.isAutoColumn">
        function <span class="apidocSignatureSpan">pdfmake.columnCalculator.</span>isAutoColumn
        <span class="apidocSignatureSpan">(column)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAutoColumn(column) {
	return column.width === &#x27;auto&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.columnCalculator.isStarColumn" id="apidoc.element.pdfmake.columnCalculator.isStarColumn">
        function <span class="apidocSignatureSpan">pdfmake.columnCalculator.</span>isStarColumn
        <span class="apidocSignatureSpan">(column)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStarColumn(column) {
	return column.width === null || column.width === undefined || column.width === &#x27;*&#x27; || column.width === &#x27;star&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.columnCalculator.measureMinMax" id="apidoc.element.pdfmake.columnCalculator.measureMinMax">
        function <span class="apidocSignatureSpan">pdfmake.columnCalculator.</span>measureMinMax
        <span class="apidocSignatureSpan">(columns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function measureMinMax(columns) {
	var result = {min: 0, max: 0};

	var maxStar = {min: 0, max: 0};
	var starCount = 0;

	for (var i = 0, l = columns.length; i &#x3c; l; i++) {
		var c = columns[i];

		if (isStarColumn(c)) {
			maxStar.min = Math.max(maxStar.min, c._minWidth);
			maxStar.max = Math.max(maxStar.max, c._maxWidth);
			starCount++;
		} else if (isAutoColumn(c)) {
			result.min += c._minWidth;
			result.max += c._maxWidth;
		} else {
			result.min += ((c.width !== undefined &#x26;&#x26; c.width) || c._minWidth);
			result.max += ((c.width !== undefined &#x26;&#x26; c.width) || c._maxWidth);
		}
	}

	if (starCount) {
		result.min += starCount * maxStar.min;
		result.max += starCount * maxStar.max;
	}

	return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var columns = node.columns;
	node._gap = this.styleStack.getProperty(&#x27;columnGap&#x27;) || 0;

	for (var i = 0, l = columns.length; i &#x3c; l; i++) {
		columns[i] = this.measureNode(columns[i]);
	}

	var measures = ColumnCalculator.<span class="apidocCodeKeywordSpan">measureMinMax</span>(columns);

	node._minWidth = measures.min + node._gap * (columns.length - 1);
	node._maxWidth = measures.max + node._gap * (columns.length - 1);

	return node;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.docMeasure" id="apidoc.module.pdfmake.docMeasure">module pdfmake.docMeasure</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.docMeasure" id="apidoc.element.pdfmake.docMeasure.docMeasure">
        function <span class="apidocSignatureSpan">pdfmake.</span>docMeasure
        <span class="apidocSignatureSpan">(fontProvider, styleDictionary, defaultStyle, imageMeasure, tableLayouts, images)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DocMeasure(fontProvider, styleDictionary, defaultStyle, imageMeasure, tableLayouts, images) {
	this.textTools = new TextTools(fontProvider);
	this.styleStack = new StyleContextStack(styleDictionary, defaultStyle);
	this.imageMeasure = imageMeasure;
	this.tableLayouts = tableLayouts;
	this.images = images;
	this.autoImageIndex = 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.docMeasure.prototype" id="apidoc.module.pdfmake.docMeasure.prototype">module pdfmake.docMeasure.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.buildOrderedMarker" id="apidoc.element.pdfmake.docMeasure.prototype.buildOrderedMarker">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>buildOrderedMarker
        <span class="apidocSignatureSpan">(counter, styleStack, type, separator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildOrderedMarker = function (counter, styleStack, type, separator) {
	function prepareAlpha(counter) {
		function toAlpha(num) {
			return (num &#x3e;= 26 ? toAlpha((num / 26 &#x3e;&#x3e; 0) - 1) : &#x27;&#x27;) + &#x27;abcdefghijklmnopqrstuvwxyz&#x27;[num % 26 &#x3e;&#x3e; 0];
		}

		if (counter &#x3c; 1) {
			return counter.toString();
		}

		return toAlpha(counter - 1);
	}

	function prepareRoman(counter) {
		if (counter &#x3c; 1 || counter &#x3e; 4999) {
			return counter.toString();
		}
		var num = counter;
		var lookup = {M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1}, roman = &#x27;&#x27;,
i;
		for (i in lookup) {
			while (num &#x3e;= lookup[i]) {
				roman += i;
				num -= lookup[i];
			}
		}
		return roman;
	}

	function prepareDecimal(counter) {
		return counter.toString();
	}

	var counterText;
	switch (type) {
		case &#x27;none&#x27;:
			counterText = null;
			break;

		case &#x27;upper-alpha&#x27;:
			counterText = prepareAlpha(counter).toUpperCase();
			break;

		case &#x27;lower-alpha&#x27;:
			counterText = prepareAlpha(counter);
			break;

		case &#x27;upper-roman&#x27;:
			counterText = prepareRoman(counter);
			break;

		case &#x27;lower-roman&#x27;:
			counterText = prepareRoman(counter).toLowerCase();
			break;

		case &#x27;decimal&#x27;:
		default:
			counterText = prepareDecimal(counter);
			break;
	}

	if (counterText === null) {
		return {};
	}

	if (separator) {
		if (Array.isArray(separator)) {
			if (separator[0]) {
				counterText = separator[0] + counterText;
			}

			if (separator[1]) {
				counterText += separator[1];
			}
			counterText += &#x27; &#x27;;
		} else {
			counterText += separator + &#x27; &#x27;;
		}
	}

	var textArray = {text: counterText};
	var markerColor = styleStack.getProperty(&#x27;markerColor&#x27;);
	if (markerColor) {
		textArray.color = markerColor;
	}

	return {_inlines: this.textTools.buildInlines(textArray, styleStack).items};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	node._maxWidth = 0;

	var counter = node.start;
	for (var i = 0, l = items.length; i &#x3c; l; i++) {
		var item = items[i] = this.measureNode(items[i]);

		if (!item.ol &#x26;&#x26; !item.ul) {
			item.listMarker = this.<span class="apidocCodeKeywordSpan">buildOrderedMarker</span>(item.counter || counter, style, node.type
, node.separator);
			if (item.listMarker._inlines) {
				node._gapSize.width = Math.max(node._gapSize.width, item.listMarker._inlines[0].width);
			}
		}  // TODO: else - nested lists numbering

		node._minWidth = Math.max(node._minWidth, items[i]._minWidth);
		node._maxWidth = Math.max(node._maxWidth, items[i]._maxWidth);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.buildUnorderedMarker" id="apidoc.element.pdfmake.docMeasure.prototype.buildUnorderedMarker">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>buildUnorderedMarker
        <span class="apidocSignatureSpan">(styleStack, gapSize, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildUnorderedMarker = function (styleStack, gapSize, type) {
	function buildDisc(gapSize, color) {
		// TODO: ascender-based calculations
		var radius = gapSize.fontSize / 6;
		return {
			canvas: [{
					x: radius,
					y: (gapSize.height / gapSize.lineHeight) + gapSize.descender - gapSize.fontSize / 3,
					r1: radius,
					r2: radius,
					type: &#x27;ellipse&#x27;,
					color: color
				}]
		};
	}

	function buildSquare(gapSize, color) {
		// TODO: ascender-based calculations
		var size = gapSize.fontSize / 3;
		return {
			canvas: [{
					x: 0,
					y: (gapSize.height / gapSize.lineHeight) + gapSize.descender - (gapSize.fontSize / 3) - (size / 2),
					h: size,
					w: size,
					type: &#x27;rect&#x27;,
					color: color
				}]
		};
	}

	function buildCircle(gapSize, color) {
		// TODO: ascender-based calculations
		var radius = gapSize.fontSize / 6;
		return {
			canvas: [{
					x: radius,
					y: (gapSize.height / gapSize.lineHeight) + gapSize.descender - gapSize.fontSize / 3,
					r1: radius,
					r2: radius,
					type: &#x27;ellipse&#x27;,
					lineColor: color
				}]
		};
	}

	var marker;
	var color = styleStack.getProperty(&#x27;markerColor&#x27;) || styleStack.getProperty(&#x27;color&#x27;) || &#x27;black&#x27;;

	switch (type) {
		case &#x27;circle&#x27;:
			marker = buildCircle(gapSize, color);
			break;

		case &#x27;square&#x27;:
			marker = buildSquare(gapSize, color);
			break;

		case &#x27;none&#x27;:
			marker = {};
			break;

		case &#x27;disc&#x27;:
		default:
			marker = buildDisc(gapSize, color);
			break;
	}

	marker._minWidth = marker._maxWidth = gapSize.width;
	marker._minHeight = marker._maxHeight = gapSize.height;

	return marker;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	node._minWidth = 0;
	node._maxWidth = 0;

	for (var i = 0, l = items.length; i &#x3c; l; i++) {
		var item = items[i] = this.measureNode(items[i]);

		if (!item.ol &#x26;&#x26; !item.ul) {
			item.listMarker = this.<span class="apidocCodeKeywordSpan">buildUnorderedMarker</span>(style, node._gapSize, node.type);
		}

		node._minWidth = Math.max(node._minWidth, items[i]._minWidth + node._gapSize.width);
		node._maxWidth = Math.max(node._maxWidth, items[i]._maxWidth + node._gapSize.width);
	}

	return node;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.convertIfBase64Image" id="apidoc.element.pdfmake.docMeasure.prototype.convertIfBase64Image">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>convertIfBase64Image
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">convertIfBase64Image = function (node) {
	if (/^data:image\/(jpeg|jpg|png);base64,/.test(node.image)) {
		var label = &#x27;$$pdfmake$$&#x27; + this.autoImageIndex++;
		this.images[label] = node.image;
		node.image = label;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.images[label] = node.image;
		node.image = label;
	}
};

DocMeasure.prototype.measureImage = function (node) {
	if (this.images) {
		this.<span class="apidocCodeKeywordSpan">convertIfBase64Image</span>(node);
	}

	var imageSize = this.imageMeasure.measureImage(node.image);

	if (node.fit) {
		var factor = (imageSize.width / imageSize.height &#x3e; node.fit[0] / node.fit[1]) ? node.fit[0] / imageSize.width : node.fit[
1] / imageSize.height;
		node._width = node._minWidth = node._maxWidth = imageSize.width * factor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.gapSizeForList" id="apidoc.element.pdfmake.docMeasure.prototype.gapSizeForList">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>gapSizeForList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gapSizeForList = function () {
	return this.textTools.sizeOfString(&#x27;9. &#x27;, this.styleStack);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	return {_inlines: this.textTools.buildInlines(textArray, styleStack).items};
};

DocMeasure.prototype.measureUnorderedList = function (node) {
	var style = this.styleStack.clone();
	var items = node.ul;
	node.type = node.type || &#x27;disc&#x27;;
	node._gapSize = this.<span class="apidocCodeKeywordSpan">gapSizeForList</span>();
	node._minWidth = 0;
	node._maxWidth = 0;

	for (var i = 0, l = items.length; i &#x3c; l; i++) {
		var item = items[i] = this.measureNode(items[i]);

		if (!item.ol &#x26;&#x26; !item.ul) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.measureCanvas" id="apidoc.element.pdfmake.docMeasure.prototype.measureCanvas">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureCanvas
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">measureCanvas = function (node) {
	var w = 0, h = 0;

	for (var i = 0, l = node.canvas.length; i &#x3c; l; i++) {
		var vector = node.canvas[i];

		switch (vector.type) {
			case &#x27;ellipse&#x27;:
				w = Math.max(w, vector.x + vector.r1);
				h = Math.max(h, vector.y + vector.r2);
				break;
			case &#x27;rect&#x27;:
				w = Math.max(w, vector.x + vector.w);
				h = Math.max(h, vector.y + vector.h);
				break;
			case &#x27;line&#x27;:
				w = Math.max(w, vector.x1, vector.x2);
				h = Math.max(h, vector.y1, vector.y2);
				break;
			case &#x27;polyline&#x27;:
				for (var i2 = 0, l2 = vector.points.length; i2 &#x3c; l2; i2++) {
					w = Math.max(w, vector.points[i2].x);
					h = Math.max(h, vector.points[i2].y);
				}
				break;
		}
	}

	node._minWidth = node._maxWidth = w;
	node._minHeight = node._maxHeight = h;

	return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else if (node.table) {
			return extendMargins(self.measureTable(node));
		} else if (node.text !== undefined) {
			return extendMargins(self.measureLeaf(node));
		} else if (node.image) {
			return extendMargins(self.measureImage(node));
		} else if (node.canvas) {
			return extendMargins(self.<span class="apidocCodeKeywordSpan">measureCanvas</span>(node));
		} else if (node.qr) {
			return extendMargins(self.measureQr(node));
		} else {
			throw &#x27;Unrecognized document structure: &#x27; + JSON.stringify(node, fontStringify);
		}
	});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.measureColumns" id="apidoc.element.pdfmake.docMeasure.prototype.measureColumns">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureColumns
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">measureColumns = function (node) {
	var columns = node.columns;
	node._gap = this.styleStack.getProperty(&#x27;columnGap&#x27;) || 0;

	for (var i = 0, l = columns.length; i &#x3c; l; i++) {
		columns[i] = this.measureNode(columns[i]);
	}

	var measures = ColumnCalculator.measureMinMax(columns);

	node._minWidth = measures.min + node._gap * (columns.length - 1);
	node._maxWidth = measures.max + node._gap * (columns.length - 1);

	return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var self = this;

	return this.styleStack.auto(node, function () {
		// TODO: refactor + rethink whether this is the proper way to handle margins
		node._margin = getNodeMargin(node);

		if (node.columns) {
			return extendMargins(self.<span class="apidocCodeKeywordSpan">measureColumns</span>(node));
		} else if (node.stack) {
			return extendMargins(self.measureVerticalContainer(node));
		} else if (node.ul) {
			return extendMargins(self.measureUnorderedList(node));
		} else if (node.ol) {
			return extendMargins(self.measureOrderedList(node));
		} else if (node.table) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.measureDocument" id="apidoc.element.pdfmake.docMeasure.prototype.measureDocument">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureDocument
        <span class="apidocSignatureSpan">(docStructure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">measureDocument = function (docStructure) {
	return this.measureNode(docStructure);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	return result.pages;
};

LayoutBuilder.prototype.tryLayoutDocument = function (docStructure, fontProvider, styleDictionary, defaultStyle, background, header
, footer, images, watermark, pageBreakBeforeFct) {

	this.linearNodeList = [];
	docStructure = this.docMeasure.<span class="apidocCodeKeywordSpan">measureDocument</span>(docStructure);

	this.writer = new PageElementWriter(
		new DocumentContext(this.pageSize, this.pageMargins), this.tracker);

	var _this = this;
	this.writer.context().tracker.startTracking(&#x27;pageAdded&#x27;, function () {
		_this.addBackground(background);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.measureImage" id="apidoc.element.pdfmake.docMeasure.prototype.measureImage">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureImage
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">measureImage = function (node) {
	if (this.images) {
		this.convertIfBase64Image(node);
	}

	var imageSize = this.imageMeasure.measureImage(node.image);

	if (node.fit) {
		var factor = (imageSize.width / imageSize.height &#x3e; node.fit[0] / node.fit[1]) ? node.fit[0] / imageSize.width : node.fit[1] /
imageSize.height;
		node._width = node._minWidth = node._maxWidth = imageSize.width * factor;
		node._height = imageSize.height * factor;
	} else {
		node._width = node._minWidth = node._maxWidth = node.width || imageSize.width;
		node._height = node.height || (imageSize.height * node._width / imageSize.width);
	}

	node._alignment = this.styleStack.getProperty(&#x27;alignment&#x27;);
	return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else if (node.ol) {
			return extendMargins(self.measureOrderedList(node));
		} else if (node.table) {
			return extendMargins(self.measureTable(node));
		} else if (node.text !== undefined) {
			return extendMargins(self.measureLeaf(node));
		} else if (node.image) {
			return extendMargins(self.<span class="apidocCodeKeywordSpan">measureImage</span>(node));
		} else if (node.canvas) {
			return extendMargins(self.measureCanvas(node));
		} else if (node.qr) {
			return extendMargins(self.measureQr(node));
		} else {
			throw &#x27;Unrecognized document structure: &#x27; + JSON.stringify(node, fontStringify);
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.measureLeaf" id="apidoc.element.pdfmake.docMeasure.prototype.measureLeaf">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureLeaf
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">measureLeaf = function (node) {

	// Make sure style properties of the node itself are considered when building inlines.
	// We could also just pass [node] to buildInlines, but that fails for bullet points.
	var styleStack = this.styleStack.clone();
	styleStack.push(node);

	var data = this.textTools.buildInlines(node.text, styleStack);

	node._inlines = data.items;
	node._minWidth = data.minWidth;
	node._maxWidth = data.maxWidth;

	return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else if (node.ul) {
			return extendMargins(self.measureUnorderedList(node));
		} else if (node.ol) {
			return extendMargins(self.measureOrderedList(node));
		} else if (node.table) {
			return extendMargins(self.measureTable(node));
		} else if (node.text !== undefined) {
			return extendMargins(self.<span class="apidocCodeKeywordSpan">measureLeaf</span>(node));
		} else if (node.image) {
			return extendMargins(self.measureImage(node));
		} else if (node.canvas) {
			return extendMargins(self.measureCanvas(node));
		} else if (node.qr) {
			return extendMargins(self.measureQr(node));
		} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.measureNode" id="apidoc.element.pdfmake.docMeasure.prototype.measureNode">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">measureNode = function (node) {
	// expand shortcuts
	if (Array.isArray(node)) {
		node = {stack: node};
	} else if (typeof node === &#x27;string&#x27; || node instanceof String) {
		node = {text: node};
	} else if (typeof node === &#x27;number&#x27; || typeof node === &#x27;boolean&#x27;) {
		node = {text: node.toString()};
	} else if (node === null) {
		node = {text: &#x27;&#x27;};
	}

	// Deal with empty nodes to prevent crash in getNodeMargin
	if (Object.keys(node).length === 0) {
		// A warning could be logged: console.warn(&#x27;pdfmake: Empty node, ignoring it&#x27;);
		node = {text: &#x27;&#x27;};
	}

	var self = this;

	return this.styleStack.auto(node, function () {
		// TODO: refactor + rethink whether this is the proper way to handle margins
		node._margin = getNodeMargin(node);

		if (node.columns) {
			return extendMargins(self.measureColumns(node));
		} else if (node.stack) {
			return extendMargins(self.measureVerticalContainer(node));
		} else if (node.ul) {
			return extendMargins(self.measureUnorderedList(node));
		} else if (node.ol) {
			return extendMargins(self.measureOrderedList(node));
		} else if (node.table) {
			return extendMargins(self.measureTable(node));
		} else if (node.text !== undefined) {
			return extendMargins(self.measureLeaf(node));
		} else if (node.image) {
			return extendMargins(self.measureImage(node));
		} else if (node.canvas) {
			return extendMargins(self.measureCanvas(node));
		} else if (node.qr) {
			return extendMargins(self.measureQr(node));
		} else {
			throw &#x27;Unrecognized document structure: &#x27; + JSON.stringify(node, fontStringify);
		}
	});

	function extendMargins(node) {
		var margin = node._margin;

		if (margin) {
			node._minWidth += margin[0] + margin[2];
			node._maxWidth += margin[0] + margin[2];
		}

		return node;
	}

	function getNodeMargin() {

		function processSingleMargins(node, currentMargin) {
			if (node.marginLeft || node.marginTop || node.marginRight || node.marginBottom) {
				return [
					node.marginLeft || currentMargin[0] || 0,
					node.marginTop || currentMargin[1] || 0,
					node.marginRight || currentMargin[2] || 0,
					node.marginBottom || currentMargin[3] || 0
				];
			}
			return currentMargin;
		}

		function flattenStyleArray(styleArray) {
			var flattenedStyles = {};
			for (var i = styleArray.length - 1; i &#x3e;= 0; i--) {
				var styleName = styleArray[i];
				var style = self.styleStack.styleDictionary[styleName];
				for (var key in style) {
					if (style.hasOwnProperty(key)) {
						flattenedStyles[key] = style[key];
					}
				}
			}
			return flattenedStyles;
		}

		function convertMargin(margin) {
			if (typeof margin === &#x27;number&#x27; || margin instanceof Number) {
				margin = [margin, margin, margin, margin];
			} else if (Array.isArray(margin)) {
				if (margin.length === 2) {
					margin = [margin[0], margin[1], margin[0], margin[1]];
				}
			}
			return margin;
		}

		var margin = [undefined, undefined, undefined, undefined];

		if (node.style) {
			var styleArray = (Array.isArray(node.style)) ? node.style : [node.style];
			var flattenedStyleArray = flattenStyleArray(styleArray);

			if (flattenedStyleArray) {
				margin = processSingleMargins(flattenedStyleArray, margin);
			}

			if (flattenedStyleArray.margin) {
				margin = convertMargin(flattenedStyleArray.margin);
			}
		}

		margin = processSingleMargins(node, margin);

		if (node.margin) {
			margin = convertMargin(node.margin);
		}

		if (margin[0] === undefined &#x26;&#x26; margin[1] === undefined &#x26;&#x26; margin[2] === undefined &#x26;&#x26; margin[3] === undefined) {
			return null;
		} else {
			return margin;
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Measures all nodes and sets min/max-width properties required for the second
 * layout-pass.
 * @param  {Object} docStructure document-definition-object
 * @return {Object}              document-measurement-object
 */
DocMeasure.prototype.measureDocument = function (docStructure) {
	return this.<span class="apidocCodeKeywordSpan">measureNode</span>(docStructure);
};

DocMeasure.prototype.measureNode = function (node) {
	// expand shortcuts
	if (Array.isArray(node)) {
		node = {stack: node};
	} else if (typeof node === &#x27;string&#x27; || node instanceof String) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.measureOrderedList" id="apidoc.element.pdfmake.docMeasure.prototype.measureOrderedList">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureOrderedList
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">measureOrderedList = function (node) {
	var style = this.styleStack.clone();
	var items = node.ol;
	node.type = node.type || &#x27;decimal&#x27;;
	node.separator = node.separator || &#x27;.&#x27;;
	node.reversed = node.reversed || false;
	if (!node.start) {
		node.start = node.reversed ? items.length : 1;
	}
	node._gapSize = this.gapSizeForList();
	node._minWidth = 0;
	node._maxWidth = 0;

	var counter = node.start;
	for (var i = 0, l = items.length; i &#x3c; l; i++) {
		var item = items[i] = this.measureNode(items[i]);

		if (!item.ol &#x26;&#x26; !item.ul) {
			item.listMarker = this.buildOrderedMarker(item.counter || counter, style, node.type, node.separator);
			if (item.listMarker._inlines) {
				node._gapSize.width = Math.max(node._gapSize.width, item.listMarker._inlines[0].width);
			}
		}  // TODO: else - nested lists numbering

		node._minWidth = Math.max(node._minWidth, items[i]._minWidth);
		node._maxWidth = Math.max(node._maxWidth, items[i]._maxWidth);

		if (node.reversed) {
			counter--;
		} else {
			counter++;
		}
	}

	node._minWidth += node._gapSize.width;
	node._maxWidth += node._gapSize.width;

	for (var i = 0, l = items.length; i &#x3c; l; i++) {
		var item = items[i];
		if (!item.ol &#x26;&#x26; !item.ul) {
			item.listMarker._minWidth = item.listMarker._maxWidth = node._gapSize.width;
		}
	}

	return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		if (node.columns) {
			return extendMargins(self.measureColumns(node));
		} else if (node.stack) {
			return extendMargins(self.measureVerticalContainer(node));
		} else if (node.ul) {
			return extendMargins(self.measureUnorderedList(node));
		} else if (node.ol) {
			return extendMargins(self.<span class="apidocCodeKeywordSpan">measureOrderedList</span>(node));
		} else if (node.table) {
			return extendMargins(self.measureTable(node));
		} else if (node.text !== undefined) {
			return extendMargins(self.measureLeaf(node));
		} else if (node.image) {
			return extendMargins(self.measureImage(node));
		} else if (node.canvas) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.measureQr" id="apidoc.element.pdfmake.docMeasure.prototype.measureQr">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureQr
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">measureQr = function (node) {
	node = qrEncoder.measure(node);
	node._alignment = this.styleStack.getProperty(&#x27;alignment&#x27;);
	return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else if (node.text !== undefined) {
			return extendMargins(self.measureLeaf(node));
		} else if (node.image) {
			return extendMargins(self.measureImage(node));
		} else if (node.canvas) {
			return extendMargins(self.measureCanvas(node));
		} else if (node.qr) {
			return extendMargins(self.<span class="apidocCodeKeywordSpan">measureQr</span>(node));
		} else {
			throw &#x27;Unrecognized document structure: &#x27; + JSON.stringify(node, fontStringify);
		}
	});

	function extendMargins(node) {
		var margin = node._margin;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.measureTable" id="apidoc.element.pdfmake.docMeasure.prototype.measureTable">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureTable
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">measureTable = function (node) {
	extendTableWidths(node);
	node._layout = getLayout(this.tableLayouts);
	node._offsets = getOffsets(node._layout);

	var colSpans = [];
	var col, row, cols, rows;

	for (col = 0, cols = node.table.body[0].length; col &#x3c; cols; col++) {
		var c = node.table.widths[col];
		c._minWidth = 0;
		c._maxWidth = 0;

		for (row = 0, rows = node.table.body.length; row &#x3c; rows; row++) {
			var rowData = node.table.body[row];
			var data = rowData[col];
			if (data === undefined) {
				console.error(&#x27;Malformed table row &#x27;, rowData, &#x27;in node &#x27;, node);
				throw &#x27;Malformed table row, a cell is undefined.&#x27;;
			}
			if (data === null) { // transform to object
				data = &#x27;&#x27;;
			}
			if (!data._span) {
				data = rowData[col] = this.styleStack.auto(data, measureCb(this, data));

				if (data.colSpan &#x26;&#x26; data.colSpan &#x3e; 1) {
					markSpans(rowData, col, data.colSpan);
					colSpans.push({col: col, span: data.colSpan, minWidth: data._minWidth, maxWidth: data._maxWidth});
				} else {
					c._minWidth = Math.max(c._minWidth, data._minWidth);
					c._maxWidth = Math.max(c._maxWidth, data._maxWidth);
				}
			}

			if (data.rowSpan &#x26;&#x26; data.rowSpan &#x3e; 1) {
				markVSpans(node.table, row, col, data.rowSpan);
			}
		}
	}

	extendWidthsForColSpans();

	var measures = ColumnCalculator.measureMinMax(node.table.widths);

	node._minWidth = measures.min + node._offsets.total;
	node._maxWidth = measures.max + node._offsets.total;

	return node;

	function measureCb(_this, data) {
		return function () {
			if (data !== null &#x26;&#x26; typeof data === &#x27;object&#x27;) {
				data.fillColor = _this.styleStack.getProperty(&#x27;fillColor&#x27;);
			}
			return _this.measureNode(data);
		};
	}

	function getLayout(tableLayouts) {
		var layout = node.layout;

		if (typeof node.layout === &#x27;string&#x27; || node instanceof String) {
			layout = tableLayouts[layout];
		}

		/*jshint unused: false */
		var defaultLayout = {
			hLineWidth: function (i, node) {
				return 1;
			},
			vLineWidth: function (i, node) {
				return 1;
			},
			hLineColor: function (i, node) {
				return &#x27;black&#x27;;
			},
			vLineColor: function (i, node) {
				return &#x27;black&#x27;;
			},
			paddingLeft: function (i, node) {
				return 4;
			},
			paddingRight: function (i, node) {
				return 4;
			},
			paddingTop: function (i, node) {
				return 2;
			},
			paddingBottom: function (i, node) {
				return 2;
			},
			fillColor: function (i, node) {
				return null;
			},
			defaultBorder: true
		};

		return pack(defaultLayout, layout);
	}

	function getOffsets(layout) {
		var offsets = [];
		var totalOffset = 0;
		var prevRightPadding = 0;

		for (var i = 0, l = node.table.widths.length; i &#x3c; l; i++) {
			var lOffset = prevRightPadding + layout.vLineWidth(i, node) + layout.paddingLeft(i, node);
			offsets.push(lOffset);
			totalOffset += lOffset;
			prevRightPadding = layout.paddingRight(i, node);
		}

		totalOffset += prevRightPadding + layout.vLineWidth(node.table.widths.length, node);

		return {
			total: totalOffset,
			offsets: offsets
		};
	}

	function extendWidthsForColSpans() {
		var q, j;

		for (var i = 0, l = colSpans.length; i &#x3c; l; i++) {
			var span = colSpans[i];

			var currentMinMax = getMinMax(span.col, span.span, node._offsets);
			var minDifference = span.minWidth - currentMinMax.minWidth;
			var maxDifference = span.maxWidth - currentMinMax.maxWidth;

			if (minDifference &#x3e; 0) {
				q = minDifference / span.span;

				for (j = 0; j &#x3c; span.span; j++) {
					node.table.widths[span.col + j]._minWidth += q;
				}
			}

			if (maxDifference &#x3e; 0) {
				q = maxDifference / span.span;

				for (j = 0; j &#x3c; span.span; j++) {
					node.table.widths[span.col + j]._maxWidth += q;
				}
			}
		}
	}

	function getMinMax(col, span, offsets) {
		var result = {minWidth: 0, maxWidth: 0};

		for (var i = 0; i &#x3c; span; i++) {
			result.minWidth += node.table.widths[col + i]._minWidth + (i ? offsets.offsets[col + i] : 0);
			result.maxWidth += node.table.widths[col + ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else if (node.stack) {
			return extendMargins(self.measureVerticalContainer(node));
		} else if (node.ul) {
			return extendMargins(self.measureUnorderedList(node));
		} else if (node.ol) {
			return extendMargins(self.measureOrderedList(node));
		} else if (node.table) {
			return extendMargins(self.<span class="apidocCodeKeywordSpan">measureTable</span>(node));
		} else if (node.text !== undefined) {
			return extendMargins(self.measureLeaf(node));
		} else if (node.image) {
			return extendMargins(self.measureImage(node));
		} else if (node.canvas) {
			return extendMargins(self.measureCanvas(node));
		} else if (node.qr) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.measureUnorderedList" id="apidoc.element.pdfmake.docMeasure.prototype.measureUnorderedList">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureUnorderedList
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">measureUnorderedList = function (node) {
	var style = this.styleStack.clone();
	var items = node.ul;
	node.type = node.type || &#x27;disc&#x27;;
	node._gapSize = this.gapSizeForList();
	node._minWidth = 0;
	node._maxWidth = 0;

	for (var i = 0, l = items.length; i &#x3c; l; i++) {
		var item = items[i] = this.measureNode(items[i]);

		if (!item.ol &#x26;&#x26; !item.ul) {
			item.listMarker = this.buildUnorderedMarker(style, node._gapSize, node.type);
		}

		node._minWidth = Math.max(node._minWidth, items[i]._minWidth + node._gapSize.width);
		node._maxWidth = Math.max(node._maxWidth, items[i]._maxWidth + node._gapSize.width);
	}

	return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		node._margin = getNodeMargin(node);

		if (node.columns) {
			return extendMargins(self.measureColumns(node));
		} else if (node.stack) {
			return extendMargins(self.measureVerticalContainer(node));
		} else if (node.ul) {
			return extendMargins(self.<span class="apidocCodeKeywordSpan">measureUnorderedList</span>(node));
		} else if (node.ol) {
			return extendMargins(self.measureOrderedList(node));
		} else if (node.table) {
			return extendMargins(self.measureTable(node));
		} else if (node.text !== undefined) {
			return extendMargins(self.measureLeaf(node));
		} else if (node.image) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.docMeasure.prototype.measureVerticalContainer" id="apidoc.element.pdfmake.docMeasure.prototype.measureVerticalContainer">
        function <span class="apidocSignatureSpan">pdfmake.docMeasure.prototype.</span>measureVerticalContainer
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">measureVerticalContainer = function (node) {
	var items = node.stack;

	node._minWidth = 0;
	node._maxWidth = 0;

	for (var i = 0, l = items.length; i &#x3c; l; i++) {
		items[i] = this.measureNode(items[i]);

		node._minWidth = Math.max(node._minWidth, items[i]._minWidth);
		node._maxWidth = Math.max(node._maxWidth, items[i]._maxWidth);
	}

	return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	return this.styleStack.auto(node, function () {
		// TODO: refactor + rethink whether this is the proper way to handle margins
		node._margin = getNodeMargin(node);

		if (node.columns) {
			return extendMargins(self.measureColumns(node));
		} else if (node.stack) {
			return extendMargins(self.<span class="apidocCodeKeywordSpan">measureVerticalContainer</span>(node));
		} else if (node.ul) {
			return extendMargins(self.measureUnorderedList(node));
		} else if (node.ol) {
			return extendMargins(self.measureOrderedList(node));
		} else if (node.table) {
			return extendMargins(self.measureTable(node));
		} else if (node.text !== undefined) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.documentContext" id="apidoc.module.pdfmake.documentContext">module pdfmake.documentContext</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.documentContext" id="apidoc.element.pdfmake.documentContext.documentContext">
        function <span class="apidocSignatureSpan">pdfmake.</span>documentContext
        <span class="apidocSignatureSpan">(pageSize, pageMargins)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DocumentContext(pageSize, pageMargins) {
	this.pages = [];

	this.pageMargins = pageMargins;

	this.x = pageMargins.left;
	this.availableWidth = pageSize.width - pageMargins.left - pageMargins.right;
	this.availableHeight = 0;
	this.page = -1;

	this.snapshots = [];

	this.endingCell = null;

	this.tracker = new TraversalTracker();

	this.addPage(pageSize);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.documentContext.prototype" id="apidoc.module.pdfmake.documentContext.prototype">module pdfmake.documentContext.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.addMargin" id="apidoc.element.pdfmake.documentContext.prototype.addMargin">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>addMargin
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addMargin = function (left, right) {
	this.x += left;
	this.availableWidth -= left + (right || 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		if (node.pageBreak === &#x27;before&#x27;) {
			self.writer.moveToNextPage(node.pageOrientation);
		}

		if (margin) {
			self.writer.context().moveDown(margin[1]);
			self.writer.context().<span class="apidocCodeKeywordSpan">addMargin</span>(margin[0], margin[2]);
		}

		callback();

		if (margin) {
			self.writer.context().addMargin(-margin[0], -margin[2]);
			self.writer.context().moveDown(margin[3]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.addPage" id="apidoc.element.pdfmake.documentContext.prototype.addPage">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>addPage
        <span class="apidocSignatureSpan">(pageSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addPage = function (pageSize) {
	var page = {items: [], pageSize: pageSize};
	this.pages.push(page);
	this.page = this.pages.length - 1;
	this.initializePage();

	this.tracker.emit(&#x27;pageAdded&#x27;);

	return page;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	this.snapshots = [];

	this.endingCell = null;

	this.tracker = new TraversalTracker();

	this.<span class="apidocCodeKeywordSpan">addPage</span>(pageSize);
}

DocumentContext.prototype.beginColumnGroup = function () {
	this.snapshots.push({
		x: this.x,
		y: this.y,
		availableHeight: this.availableHeight,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.beginColumn" id="apidoc.element.pdfmake.documentContext.prototype.beginColumn">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>beginColumn
        <span class="apidocSignatureSpan">(width, offset, endingCell)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beginColumn = function (width, offset, endingCell) {
	var saved = this.snapshots[this.snapshots.length - 1];

	this.calculateBottomMost(saved);

	this.endingCell = endingCell;
	this.page = saved.page;
	this.x = this.x + this.lastColumnWidth + (offset || 0);
	this.y = saved.y;
	this.availableWidth = width;	//saved.availableWidth - offset;
	this.availableHeight = saved.availableHeight;

	this.lastColumnWidth = width;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

			if (column.colSpan &#x26;&#x26; column.colSpan &#x3e; 1) {
				for (var j = 1; j &#x3c; column.colSpan; j++) {
					width += widths[++i]._calcWidth + gaps[i];
				}
			}

			self.writer.context().<span class="apidocCodeKeywordSpan">beginColumn</span>(width, leftOffset, getEndingCell(column, i));
			if (!column._span) {
				self.processNode(column);
				addAll(positions, column.positions);
			} else if (column._columnEndingContext) {
				// row-span ending
				self.writer.context().markEnding(column);
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.beginColumnGroup" id="apidoc.element.pdfmake.documentContext.prototype.beginColumnGroup">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>beginColumnGroup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beginColumnGroup = function () {
	this.snapshots.push({
		x: this.x,
		y: this.y,
		availableHeight: this.availableHeight,
		availableWidth: this.availableWidth,
		page: this.page,
		bottomMost: {y: this.y, page: this.page},
		endingCell: this.endingCell,
		lastColumnWidth: this.lastColumnWidth
	});

	this.lastColumnWidth = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
LayoutBuilder.prototype.processRow = function (columns, widths, gaps, tableBody, tableRow) {
	var self = this;
	var pageBreaks = [], positions = [];

	this.tracker.auto(&#x27;pageChanged&#x27;, storePageBreakData, function () {
		widths = widths || columns;

		self.writer.context().<span class="apidocCodeKeywordSpan">beginColumnGroup</span>();

		for (var i = 0, l = columns.length; i &#x3c; l; i++) {
			var column = columns[i];
			var width = widths[i]._calcWidth;
			var leftOffset = colLeftOffset(i);

			if (column.colSpan &#x26;&#x26; column.colSpan &#x3e; 1) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.beginDetachedBlock" id="apidoc.element.pdfmake.documentContext.prototype.beginDetachedBlock">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>beginDetachedBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beginDetachedBlock = function () {
	this.snapshots.push({
		x: this.x,
		y: this.y,
		availableHeight: this.availableHeight,
		availableWidth: this.availableWidth,
		page: this.page,
		endingCell: this.endingCell,
		lastColumnWidth: this.lastColumnWidth
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	this.linearNodeList.push(node);
	decorateNode(node);

	applyMargins(function () {
		var absPosition = node.absolutePosition;
		if (absPosition) {
			self.writer.context().<span class="apidocCodeKeywordSpan">beginDetachedBlock</span>();
			self.writer.context().moveTo(absPosition.x || 0, absPosition.y || 0);
		}

		var relPosition = node.relativePosition;
		if (relPosition) {
			self.writer.context().beginDetachedBlock();
			self.writer.context().moveTo((relPosition.x || 0) + self.writer.context().x, (relPosition.y || 0) + self.writer.context().y);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.calculateBottomMost" id="apidoc.element.pdfmake.documentContext.prototype.calculateBottomMost">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>calculateBottomMost
        <span class="apidocSignatureSpan">(destContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateBottomMost = function (destContext) {
	if (this.endingCell) {
		this.saveContextInEndingCell(this.endingCell);
		this.endingCell = null;
	} else {
		destContext.bottomMost = bottomMostContext(this, destContext.bottomMost);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	this.lastColumnWidth = 0;
};

DocumentContext.prototype.beginColumn = function (width, offset, endingCell) {
	var saved = this.snapshots[this.snapshots.length - 1];

	this.<span class="apidocCodeKeywordSpan">calculateBottomMost</span>(saved);

	this.endingCell = endingCell;
	this.page = saved.page;
	this.x = this.x + this.lastColumnWidth + (offset || 0);
	this.y = saved.y;
	this.availableWidth = width;	//saved.availableWidth - offset;
	this.availableHeight = saved.availableHeight;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.completeColumnGroup" id="apidoc.element.pdfmake.documentContext.prototype.completeColumnGroup">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>completeColumnGroup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completeColumnGroup = function () {
	var saved = this.snapshots.pop();

	this.calculateBottomMost(saved);

	this.endingCell = null;
	this.x = saved.x;
	this.y = saved.bottomMost.y;
	this.page = saved.bottomMost.page;
	this.availableWidth = saved.availableWidth;
	this.availableHeight = saved.bottomMost.availableHeight;
	this.lastColumnWidth = saved.lastColumnWidth;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				addAll(positions, column.positions);
			} else if (column._columnEndingContext) {
				// row-span ending
				self.writer.context().markEnding(column);
			}
		}

		self.writer.context().<span class="apidocCodeKeywordSpan">completeColumnGroup</span>();
	});

	return {pageBreaks: pageBreaks, positions: positions};

	function storePageBreakData(data) {
		var pageDesc;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.endDetachedBlock" id="apidoc.element.pdfmake.documentContext.prototype.endDetachedBlock">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>endDetachedBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endDetachedBlock = function () {
	var saved = this.snapshots.pop();

	this.x = saved.x;
	this.y = saved.y;
	this.availableWidth = saved.availableWidth;
	this.availableHeight = saved.availableHeight;
	this.page = saved.page;
	this.endingCell = saved.endingCell;
	this.lastColumnWidth = saved.lastColumnWidth;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else if (node.qr) {
			self.processQr(node);
		} else if (!node._span) {
			throw &#x27;Unrecognized document structure: &#x27; + JSON.stringify(node, fontStringify);
		}

		if (absPosition || relPosition) {
			self.writer.context().<span class="apidocCodeKeywordSpan">endDetachedBlock</span>();
		}
	});

	function applyMargins(callback) {
		var margin = node._margin;

		if (node.pageBreak === &#x27;before&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.getCurrentPage" id="apidoc.element.pdfmake.documentContext.prototype.getCurrentPage">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>getCurrentPage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCurrentPage = function () {
	if (this.page &#x3c; 0 || this.page &#x3e;= this.pages.length) {
		return null;
	}

	return this.pages[this.page];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	this.availableHeight -= offset;

	return this.availableHeight &#x3e; 0;
};

DocumentContext.prototype.initializePage = function () {
	this.y = this.pageMargins.top;
	this.availableHeight = this.<span class="apidocCodeKeywordSpan">getCurrentPage</span>().pageSize.height - this.pageMargins.top -
this.pageMargins.bottom;
	this.pageSnapshot().availableWidth = this.getCurrentPage().pageSize.width - this.pageMargins.left - this.pageMargins.right;
};

DocumentContext.prototype.pageSnapshot = function () {
	if (this.snapshots[0]) {
		return this.snapshots[0];
	} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.getCurrentPosition" id="apidoc.element.pdfmake.documentContext.prototype.getCurrentPosition">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>getCurrentPosition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCurrentPosition = function () {
	var pageSize = this.getCurrentPage().pageSize;
	var innerHeight = pageSize.height - this.pageMargins.top - this.pageMargins.bottom;
	var innerWidth = pageSize.width - this.pageMargins.left - this.pageMargins.right;

	return {
		pageNumber: this.page + 1,
		pageOrientation: pageSize.orientation,
		pageInnerHeight: innerHeight,
		pageInnerWidth: innerWidth,
		left: this.x,
		top: this.y,
		verticalRatio: ((this.y - this.pageMargins.top) / innerHeight),
		horizontalRatio: ((this.x - this.pageMargins.left) / innerWidth)
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.initializePage" id="apidoc.element.pdfmake.documentContext.prototype.initializePage">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>initializePage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializePage = function () {
	this.y = this.pageMargins.top;
	this.availableHeight = this.getCurrentPage().pageSize.height - this.pageMargins.top - this.pageMargins.bottom;
	this.pageSnapshot().availableWidth = this.getCurrentPage().pageSize.width - this.pageMargins.left - this.pageMargins.right;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.addPage(pageSize);

		if (currentPageOrientation === pageSize.orientation) {
			this.availableWidth = currentAvailableWidth;
		}
	} else {
		this.page = nextPageIndex;
		this.<span class="apidocCodeKeywordSpan">initializePage</span>();
	}

	return {
		newPageCreated: createNewPage,
		prevPage: prevPage,
		prevY: prevY,
		y: this.y
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.markEnding" id="apidoc.element.pdfmake.documentContext.prototype.markEnding">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>markEnding
        <span class="apidocSignatureSpan">(endingCell)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">markEnding = function (endingCell) {
	this.page = endingCell._columnEndingContext.page;
	this.x = endingCell._columnEndingContext.x;
	this.y = endingCell._columnEndingContext.y;
	this.availableWidth = endingCell._columnEndingContext.availableWidth;
	this.availableHeight = endingCell._columnEndingContext.availableHeight;
	this.lastColumnWidth = endingCell._columnEndingContext.lastColumnWidth;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

			self.writer.context().beginColumn(width, leftOffset, getEndingCell(column, i));
			if (!column._span) {
				self.processNode(column);
				addAll(positions, column.positions);
			} else if (column._columnEndingContext) {
				// row-span ending
				self.writer.context().<span class="apidocCodeKeywordSpan">markEnding</span>(column);
			}
		}

		self.writer.context().completeColumnGroup();
	});

	return {pageBreaks: pageBreaks, positions: positions};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.moveDown" id="apidoc.element.pdfmake.documentContext.prototype.moveDown">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>moveDown
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveDown = function (offset) {
	this.y += offset;
	this.availableHeight -= offset;

	return this.availableHeight &#x3e; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	addPageItem(page, {
		type: &#x27;line&#x27;,
		item: line
	}, index);
	this.tracker.emit(&#x27;lineAdded&#x27;, line);

	if (!dontUpdateContextPosition) {
		context.<span class="apidocCodeKeywordSpan">moveDown</span>(height);
	}

	return position;
};

ElementWriter.prototype.alignLine = function (line) {
	var width = this.context.availableWidth;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.moveTo" id="apidoc.element.pdfmake.documentContext.prototype.moveTo">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>moveTo
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveTo = function (x, y) {
	if (x !== undefined &#x26;&#x26; x !== null) {
		this.x = x;
		this.availableWidth = this.getCurrentPage().pageSize.width - this.x - this.pageMargins.right;
	}
	if (y !== undefined &#x26;&#x26; y !== null) {
		this.y = y;
		this.availableHeight = this.getCurrentPage().pageSize.height - this.y - this.pageMargins.bottom;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	this.linearNodeList.push(node);
	decorateNode(node);

	applyMargins(function () {
		var absPosition = node.absolutePosition;
		if (absPosition) {
			self.writer.context().beginDetachedBlock();
			self.writer.context().<span class="apidocCodeKeywordSpan">moveTo</span>(absPosition.x || 0, absPosition.y || 0);
		}

		var relPosition = node.relativePosition;
		if (relPosition) {
			self.writer.context().beginDetachedBlock();
			self.writer.context().moveTo((relPosition.x || 0) + self.writer.context().x, (relPosition.y || 0) + self.writer.context().y);
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.moveToNextPage" id="apidoc.element.pdfmake.documentContext.prototype.moveToNextPage">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>moveToNextPage
        <span class="apidocSignatureSpan">(pageOrientation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveToNextPage = function (pageOrientation) {
	var nextPageIndex = this.page + 1;

	var prevPage = this.page;
	var prevY = this.y;

	var createNewPage = nextPageIndex &#x3e;= this.pages.length;
	if (createNewPage) {
		var currentAvailableWidth = this.availableWidth;
		var currentPageOrientation = this.getCurrentPage().pageSize.orientation;

		var pageSize = getPageSize(this.getCurrentPage(), pageOrientation);
		this.addPage(pageSize);

		if (currentPageOrientation === pageSize.orientation) {
			this.availableWidth = currentAvailableWidth;
		}
	} else {
		this.page = nextPageIndex;
		this.initializePage();
	}

	return {
		newPageCreated: createNewPage,
		prevPage: prevPage,
		prevY: prevY,
		y: this.y
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}
	});

	function applyMargins(callback) {
		var margin = node._margin;

		if (node.pageBreak === &#x27;before&#x27;) {
			self.writer.<span class="apidocCodeKeywordSpan">moveToNextPage</span>(node.pageOrientation);
		}

		if (margin) {
			self.writer.context().moveDown(margin[1]);
			self.writer.context().addMargin(margin[0], margin[2]);
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.pageSnapshot" id="apidoc.element.pdfmake.documentContext.prototype.pageSnapshot">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>pageSnapshot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pageSnapshot = function () {
	if (this.snapshots[0]) {
		return this.snapshots[0];
	} else {
		return this;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	return this.availableHeight &#x3e; 0;
};

DocumentContext.prototype.initializePage = function () {
	this.y = this.pageMargins.top;
	this.availableHeight = this.getCurrentPage().pageSize.height - this.pageMargins.top - this.pageMargins.bottom;
	this.<span class="apidocCodeKeywordSpan">pageSnapshot</span>().availableWidth = this.getCurrentPage().pageSize.width - this.pageMargins
.left - this.pageMargins.right;
};

DocumentContext.prototype.pageSnapshot = function () {
	if (this.snapshots[0]) {
		return this.snapshots[0];
	} else {
		return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.documentContext.prototype.saveContextInEndingCell" id="apidoc.element.pdfmake.documentContext.prototype.saveContextInEndingCell">
        function <span class="apidocSignatureSpan">pdfmake.documentContext.prototype.</span>saveContextInEndingCell
        <span class="apidocSignatureSpan">(endingCell)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saveContextInEndingCell = function (endingCell) {
	endingCell._columnEndingContext = {
		page: this.page,
		x: this.x,
		y: this.y,
		availableHeight: this.availableHeight,
		availableWidth: this.availableWidth,
		lastColumnWidth: this.lastColumnWidth
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	this.availableHeight = saved.availableHeight;

	this.lastColumnWidth = width;
};

DocumentContext.prototype.calculateBottomMost = function (destContext) {
	if (this.endingCell) {
		this.<span class="apidocCodeKeywordSpan">saveContextInEndingCell</span>(this.endingCell);
		this.endingCell = null;
	} else {
		destContext.bottomMost = bottomMostContext(this, destContext.bottomMost);
	}
};

DocumentContext.prototype.markEnding = function (endingCell) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.elementWriter" id="apidoc.module.pdfmake.elementWriter">module pdfmake.elementWriter</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.elementWriter.elementWriter" id="apidoc.element.pdfmake.elementWriter.elementWriter">
        function <span class="apidocSignatureSpan">pdfmake.</span>elementWriter
        <span class="apidocSignatureSpan">(context, tracker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ElementWriter(context, tracker) {
	this.context = context;
	this.contextStack = [];
	this.tracker = tracker;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.elementWriter.prototype" id="apidoc.module.pdfmake.elementWriter.prototype">module pdfmake.elementWriter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.elementWriter.prototype.addFragment" id="apidoc.element.pdfmake.elementWriter.prototype.addFragment">
        function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>addFragment
        <span class="apidocSignatureSpan">(block, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addFragment = function (block, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition) {
	var ctx = this.context;
	var page = ctx.getCurrentPage();

	if (!useBlockXOffset &#x26;&#x26; block.height &#x3e; ctx.availableHeight) {
		return false;
	}

	block.items.forEach(function (item) {
		switch (item.type) {
			case &#x27;line&#x27;:
				var l = cloneLine(item.item);

				l.x = (l.x || 0) + (useBlockXOffset ? (block.xOffset || 0) : ctx.x);
				l.y = (l.y || 0) + (useBlockYOffset ? (block.yOffset || 0) : ctx.y);

				page.items.push({
					type: &#x27;line&#x27;,
					item: l
				});
				break;

			case &#x27;vector&#x27;:
				var v = pack(item.item);

				offsetVector(v, useBlockXOffset ? (block.xOffset || 0) : ctx.x, useBlockYOffset ? (block.yOffset || 0) : ctx.y);
				page.items.push({
					type: &#x27;vector&#x27;,
					item: v
				});
				break;

			case &#x27;image&#x27;:
				var img = pack(item.item);

				img.x = (img.x || 0) + (useBlockXOffset ? (block.xOffset || 0) : ctx.x);
				img.y = (img.y || 0) + (useBlockYOffset ? (block.yOffset || 0) : ctx.y);

				page.items.push({
					type: &#x27;image&#x27;,
					item: img
				});
				break;
		}
	});

	if (!dontUpdateContextPosition) {
		ctx.moveDown(block.height);
	}

	return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

PageElementWriter.prototype.addVector = function (vector, ignoreContextX, ignoreContextY, index) {
	return this.writer.addVector(vector, ignoreContextX, ignoreContextY, index);
};

PageElementWriter.prototype.addFragment = function (fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition) {
	if (!this.writer.<span class="apidocCodeKeywordSpan">addFragment</span>(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition
)) {
		this.moveToNextPage();
		this.writer.addFragment(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition);
	}
};

PageElementWriter.prototype.moveToNextPage = function (pageOrientation) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.elementWriter.prototype.addImage" id="apidoc.element.pdfmake.elementWriter.prototype.addImage">
        function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>addImage
        <span class="apidocSignatureSpan">(image, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addImage = function (image, index) {
	var context = this.context;
	var page = context.getCurrentPage(),
		position = this.getCurrentPositionOnPage();

	if (context.availableHeight &#x3c; image._height || !page) {
		return false;
	}

	if (image._x === undefined) {
		image._x = image.x || 0;
	}

	image.x = context.x + image._x;
	image.y = context.y;

	this.alignImage(image);

	addPageItem(page, {
		type: &#x27;image&#x27;,
		item: image
	}, index);

	context.moveDown(image._height);

	return position;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	line.lastLineInParagraph = textNode._inlines.length === 0;

	return line;
};

// images
LayoutBuilder.prototype.processImage = function (node) {
	var position = this.writer.<span class="apidocCodeKeywordSpan">addImage</span>(node);
	node.positions.push(position);
};

LayoutBuilder.prototype.processCanvas = function (node) {
	var height = node._minHeight;

	if (this.writer.context().availableHeight &#x3c; height) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.elementWriter.prototype.addLine" id="apidoc.element.pdfmake.elementWriter.prototype.addLine">
        function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>addLine
        <span class="apidocSignatureSpan">(line, dontUpdateContextPosition, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addLine = function (line, dontUpdateContextPosition, index) {
	var height = line.getHeight();
	var context = this.context;
	var page = context.getCurrentPage(),
		position = this.getCurrentPositionOnPage();

	if (context.availableHeight &#x3c; height || !page) {
		return false;
	}

	line.x = context.x + (line.x || 0);
	line.y = context.y + (line.y || 0);

	this.alignLine(line);

	addPageItem(page, {
		type: &#x27;line&#x27;,
		item: line
	}, index);
	this.tracker.emit(&#x27;lineAdded&#x27;, line);

	if (!dontUpdateContextPosition) {
		context.moveDown(height);
	}

	return position;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				offsetVector(vector, -marker._minWidth, 0);
				self.writer.addVector(vector);
			} else if (marker._inlines) {
				var markerLine = new Line(self.pageSize.width);
				markerLine.addInline(marker._inlines[0]);
				markerLine.x = -marker._minWidth;
				markerLine.y = line.getAscenderHeight() - markerLine.getAscenderHeight();
				self.writer.<span class="apidocCodeKeywordSpan">addLine</span>(markerLine, true);
			}
		}
	}
};

// tables
LayoutBuilder.prototype.processTable = function (tableNode) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.elementWriter.prototype.addQr" id="apidoc.element.pdfmake.elementWriter.prototype.addQr">
        function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>addQr
        <span class="apidocSignatureSpan">(qr, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addQr = function (qr, index) {
	var context = this.context;
	var page = context.getCurrentPage(),
		position = this.getCurrentPositionOnPage();

	if (context.availableHeight &#x3c; qr._height || !page) {
		return false;
	}

	if (qr._x === undefined) {
		qr._x = qr.x || 0;
	}

	qr.x = context.x + qr._x;
	qr.y = context.y;

	this.alignImage(qr);

	for (var i = 0, l = qr._canvas.length; i &#x3c; l; i++) {
		var vector = qr._canvas[i];
		vector.x += qr.x;
		vector.y += qr.y;
		this.addVector(vector, true, true, index);
	}

	context.moveDown(qr._height);

	return position;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	return fitOnPage(this, function (self) {
		return self.writer.addImage(image, index);
	});
};

PageElementWriter.prototype.addQr = function (qr, index) {
	return fitOnPage(this, function (self) {
		return self.writer.<span class="apidocCodeKeywordSpan">addQr</span>(qr, index);
	});
};

PageElementWriter.prototype.addVector = function (vector, ignoreContextX, ignoreContextY, index) {
	return this.writer.addVector(vector, ignoreContextX, ignoreContextY, index);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.elementWriter.prototype.addVector" id="apidoc.element.pdfmake.elementWriter.prototype.addVector">
        function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>addVector
        <span class="apidocSignatureSpan">(vector, ignoreContextX, ignoreContextY, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addVector = function (vector, ignoreContextX, ignoreContextY, index) {
	var context = this.context;
	var page = context.getCurrentPage(),
		position = this.getCurrentPositionOnPage();

	if (page) {
		offsetVector(vector, ignoreContextX ? 0 : context.x, ignoreContextY ? 0 : context.y);
		addPageItem(page, {
			type: &#x27;vector&#x27;,
			item: vector
		}, index);
		return position;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	this.alignImage(qr);

	for (var i = 0, l = qr._canvas.length; i &#x3c; l; i++) {
		var vector = qr._canvas[i];
		vector.x += qr.x;
		vector.y += qr.y;
		this.<span class="apidocCodeKeywordSpan">addVector</span>(vector, true, true, index);
	}

	context.moveDown(qr._height);

	return position;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.elementWriter.prototype.alignImage" id="apidoc.element.pdfmake.elementWriter.prototype.alignImage">
        function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>alignImage
        <span class="apidocSignatureSpan">(image)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alignImage = function (image) {
	var width = this.context.availableWidth;
	var imageWidth = image._minWidth;
	var offset = 0;
	switch (image._alignment) {
		case &#x27;right&#x27;:
			offset = width - imageWidth;
			break;
		case &#x27;center&#x27;:
			offset = (width - imageWidth) / 2;
			break;
	}

	if (offset) {
		image.x = (image.x || 0) + offset;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	if (image._x === undefined) {
		image._x = image.x || 0;
	}

	image.x = context.x + image._x;
	image.y = context.y;

	this.<span class="apidocCodeKeywordSpan">alignImage</span>(image);

	addPageItem(page, {
		type: &#x27;image&#x27;,
		item: image
	}, index);

	context.moveDown(image._height);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.elementWriter.prototype.alignLine" id="apidoc.element.pdfmake.elementWriter.prototype.alignLine">
        function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>alignLine
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alignLine = function (line) {
	var width = this.context.availableWidth;
	var lineWidth = line.getWidth();

	var alignment = line.inlines &#x26;&#x26; line.inlines.length &#x3e; 0 &#x26;&#x26; line.inlines[0].alignment;

	var offset = 0;
	switch (alignment) {
		case &#x27;right&#x27;:
			offset = width - lineWidth;
			break;
		case &#x27;center&#x27;:
			offset = (width - lineWidth) / 2;
			break;
	}

	if (offset) {
		line.x = (line.x || 0) + offset;
	}

	if (alignment === &#x27;justify&#x27; &#x26;&#x26;
		!line.newLineForced &#x26;&#x26;
		!line.lastLineInParagraph &#x26;&#x26;
		line.inlines.length &#x3e; 1) {
		var additionalSpacing = (width - lineWidth) / (line.inlines.length - 1);

		for (var i = 1, l = line.inlines.length; i &#x3c; l; i++) {
			offset = i * additionalSpacing;

			line.inlines[i].x += offset;
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	if (context.availableHeight &#x3c; height || !page) {
		return false;
	}

	line.x = context.x + (line.x || 0);
	line.y = context.y + (line.y || 0);

	this.<span class="apidocCodeKeywordSpan">alignLine</span>(line);

	addPageItem(page, {
		type: &#x27;line&#x27;,
		item: line
	}, index);
	this.tracker.emit(&#x27;lineAdded&#x27;, line);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.elementWriter.prototype.getCurrentPositionOnPage" id="apidoc.element.pdfmake.elementWriter.prototype.getCurrentPositionOnPage">
        function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>getCurrentPositionOnPage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCurrentPositionOnPage = function () {
	return (this.contextStack[0] || this.context).getCurrentPosition();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}
}

ElementWriter.prototype.addLine = function (line, dontUpdateContextPosition, index) {
	var height = line.getHeight();
	var context = this.context;
	var page = context.getCurrentPage(),
		position = this.<span class="apidocCodeKeywordSpan">getCurrentPositionOnPage</span>();

	if (context.availableHeight &#x3c; height || !page) {
		return false;
	}

	line.x = context.x + (line.x || 0);
	line.y = context.y + (line.y || 0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.elementWriter.prototype.popContext" id="apidoc.element.pdfmake.elementWriter.prototype.popContext">
        function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>popContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">popContext = function () {
	this.context = this.contextStack.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.writer.pushContext(width, height);
	}
};

PageElementWriter.prototype.commitUnbreakableBlock = function (forcedX, forcedY) {
	if (--this.transactionLevel === 0) {
		var unbreakableContext = this.writer.context;
		this.writer.<span class="apidocCodeKeywordSpan">popContext</span>();

		var nbPages = unbreakableContext.pages.length;
		if (nbPages &#x3e; 0) {
			// no support for multi-page unbreakableBlocks
			var fragment = unbreakableContext.pages[0];
			fragment.xOffset = forcedX;
			fragment.yOffset = forcedY;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.elementWriter.prototype.pushContext" id="apidoc.element.pdfmake.elementWriter.prototype.pushContext">
        function <span class="apidocSignatureSpan">pdfmake.elementWriter.prototype.</span>pushContext
        <span class="apidocSignatureSpan">(contextOrWidth, height)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushContext = function (contextOrWidth, height) {
	if (contextOrWidth === undefined) {
		height = this.context.getCurrentPage().height - this.context.pageMargins.top - this.context.pageMargins.bottom;
		contextOrWidth = this.context.availableWidth;
	}

	if (typeof contextOrWidth === &#x27;number&#x27; || contextOrWidth instanceof Number) {
		contextOrWidth = new DocumentContext({width: contextOrWidth, height: height}, {left: 0, right: 0, top: 0, bottom: 0});
	}

	this.contextStack.push(this.context);
	this.context = contextOrWidth;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		y: nextPage.y
	});
};

PageElementWriter.prototype.beginUnbreakableBlock = function (width, height) {
	if (this.transactionLevel++ === 0) {
		this.originalX = this.writer.context.x;
		this.writer.<span class="apidocCodeKeywordSpan">pushContext</span>(width, height);
	}
};

PageElementWriter.prototype.commitUnbreakableBlock = function (forcedX, forcedY) {
	if (--this.transactionLevel === 0) {
		var unbreakableContext = this.writer.context;
		this.writer.popContext();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.fontProvider" id="apidoc.module.pdfmake.fontProvider">module pdfmake.fontProvider</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.fontProvider.fontProvider" id="apidoc.element.pdfmake.fontProvider.fontProvider">
        function <span class="apidocSignatureSpan">pdfmake.</span>fontProvider
        <span class="apidocSignatureSpan">(fontDescriptors, pdfKitDoc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FontProvider(fontDescriptors, pdfKitDoc) {
	this.fonts = {};
	this.pdfKitDoc = pdfKitDoc;
	this.fontCache = {};

	for (var font in fontDescriptors) {
		if (fontDescriptors.hasOwnProperty(font)) {
			var fontDef = fontDescriptors[font];

			this.fonts[font] = {
				normal: fontDef.normal,
				bold: fontDef.bold,
				italics: fontDef.italics,
				bolditalics: fontDef.bolditalics
			};
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.fontProvider.prototype" id="apidoc.module.pdfmake.fontProvider.prototype">module pdfmake.fontProvider.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.fontProvider.prototype.provideFont" id="apidoc.element.pdfmake.fontProvider.prototype.provideFont">
        function <span class="apidocSignatureSpan">pdfmake.fontProvider.prototype.</span>provideFont
        <span class="apidocSignatureSpan">(familyName, bold, italics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">provideFont = function (familyName, bold, italics) {
	var type = typeName(bold, italics);
	if (!this.fonts[familyName] || !this.fonts[familyName][type]) {
		throw new Error(&#x27;Font \&#x27;&#x27; + familyName + &#x27;\&#x27; in style \&#x27;&#x27; + type + &#x27;\&#x27; is not defined in the font section of the document definition
.&#x27;);
	}

	this.fontCache[familyName] = this.fontCache[familyName] || {};

	if (!this.fontCache[familyName][type]) {
		var def = this.fonts[familyName][type];
		if (!Array.isArray(def)) {
			def = [def];
		}
		this.fontCache[familyName][type] = this.pdfKitDoc.font.apply(this.pdfKitDoc, def)._font;
	}

	return this.fontCache[familyName][type];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	watermark.color = watermark.color || &#x27;black&#x27;;
	watermark.opacity = watermark.opacity || 0.6;
	watermark.bold = watermark.bold || false;
	watermark.italics = watermark.italics || false;

	var watermarkObject = {
		text: watermark.text,
		font: fontProvider.<span class="apidocCodeKeywordSpan">provideFont</span>(watermark.font, watermark.bold, watermark.italics),
		size: getSize(this.pageSize, watermark, fontProvider),
		color: watermark.color,
		opacity: watermark.opacity
	};

	var pages = this.writer.context().pages;
	for (var i = 0, l = pages.length; i &#x3c; l; i++) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.helpers" id="apidoc.module.pdfmake.helpers">module pdfmake.helpers</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.helpers.fontStringify" id="apidoc.element.pdfmake.helpers.fontStringify">
        function <span class="apidocSignatureSpan">pdfmake.helpers.</span>fontStringify
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fontStringify(key, val) {
	if (key === &#x27;font&#x27;) {
		return &#x27;font&#x27;;
	}
	return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.helpers.isFunction" id="apidoc.element.pdfmake.helpers.isFunction">
        function <span class="apidocSignatureSpan">pdfmake.helpers.</span>isFunction
        <span class="apidocSignatureSpan">(functionToCheck)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunction(functionToCheck) {
	var getType = {};
	return functionToCheck &#x26;&#x26; getType.toString.call(functionToCheck) === &#x27;[object Function]&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.helpers.offsetVector" id="apidoc.element.pdfmake.helpers.offsetVector">
        function <span class="apidocSignatureSpan">pdfmake.helpers.</span>offsetVector
        <span class="apidocSignatureSpan">(vector, x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function offsetVector(vector, x, y) {
	switch (vector.type) {
		case &#x27;ellipse&#x27;:
		case &#x27;rect&#x27;:
			vector.x += x;
			vector.y += y;
			break;
		case &#x27;line&#x27;:
			vector.x1 += x;
			vector.x2 += x;
			vector.y1 += y;
			vector.y2 += y;
			break;
		case &#x27;polyline&#x27;:
			for (var i = 0, l = vector.points.length; i &#x3c; l; i++) {
				vector.points[i].x += x;
				vector.points[i].y += y;
			}
			break;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.helpers.pack" id="apidoc.element.pdfmake.helpers.pack">
        function <span class="apidocSignatureSpan">pdfmake.helpers.</span>pack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pack() {
	var result = {};

	for (var i = 0, l = arguments.length; i &#x3c; l; i++) {
		var obj = arguments[i];

		if (obj) {
			for (var key in obj) {
				if (obj.hasOwnProperty(key)) {
					result[key] = obj[key];
				}
			}
		}
	}

	return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.imageMeasure" id="apidoc.module.pdfmake.imageMeasure">module pdfmake.imageMeasure</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.imageMeasure.imageMeasure" id="apidoc.element.pdfmake.imageMeasure.imageMeasure">
        function <span class="apidocSignatureSpan">pdfmake.</span>imageMeasure
        <span class="apidocSignatureSpan">(pdfKitDoc, imageDictionary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ImageMeasure(pdfKitDoc, imageDictionary) {
	this.pdfKitDoc = pdfKitDoc;
	this.imageDictionary = imageDictionary || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.imageMeasure.prototype" id="apidoc.module.pdfmake.imageMeasure.prototype">module pdfmake.imageMeasure.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.imageMeasure.prototype.measureImage" id="apidoc.element.pdfmake.imageMeasure.prototype.measureImage">
        function <span class="apidocSignatureSpan">pdfmake.imageMeasure.prototype.</span>measureImage
        <span class="apidocSignatureSpan">(src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">measureImage = function (src) {
	var image, label;
	var that = this;

	if (!this.pdfKitDoc._imageRegistry[src]) {
		label = &#x27;I&#x27; + (++this.pdfKitDoc._imageCount);
		try {
			image = PDFImage.open(realImageSrc(src), label);
		} catch (error) {
			image = null;
		}
		if (image === null || image === undefined) {
			throw &#x27;invalid image, images dictionary should contain dataURL entries (or local file paths in node.js)&#x27;;
		}
		image.embed(this.pdfKitDoc);
		this.pdfKitDoc._imageRegistry[src] = image;
	} else {
		image = this.pdfKitDoc._imageRegistry[src];
	}

	return {width: image.width, height: image.height};

	function realImageSrc(src) {
		var img = that.imageDictionary[src];

		if (!img) {
			return src;
		}

		var index = img.indexOf(&#x27;base64,&#x27;);
		if (index &#x3c; 0) {
			return that.imageDictionary[src];
		}

		return new Buffer(img.substring(index + 7), &#x27;base64&#x27;);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else if (node.ol) {
			return extendMargins(self.measureOrderedList(node));
		} else if (node.table) {
			return extendMargins(self.measureTable(node));
		} else if (node.text !== undefined) {
			return extendMargins(self.measureLeaf(node));
		} else if (node.image) {
			return extendMargins(self.<span class="apidocCodeKeywordSpan">measureImage</span>(node));
		} else if (node.canvas) {
			return extendMargins(self.measureCanvas(node));
		} else if (node.qr) {
			return extendMargins(self.measureQr(node));
		} else {
			throw &#x27;Unrecognized document structure: &#x27; + JSON.stringify(node, fontStringify);
		}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.layoutBuilder" id="apidoc.module.pdfmake.layoutBuilder">module pdfmake.layoutBuilder</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.layoutBuilder" id="apidoc.element.pdfmake.layoutBuilder.layoutBuilder">
        function <span class="apidocSignatureSpan">pdfmake.</span>layoutBuilder
        <span class="apidocSignatureSpan">(pageSize, pageMargins, imageMeasure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LayoutBuilder(pageSize, pageMargins, imageMeasure) {
	this.pageSize = pageSize;
	this.pageMargins = pageMargins;
	this.tracker = new TraversalTracker();
	this.imageMeasure = imageMeasure;
	this.tableLayouts = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.layoutBuilder.prototype" id="apidoc.module.pdfmake.layoutBuilder.prototype">module pdfmake.layoutBuilder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.addBackground" id="apidoc.element.pdfmake.layoutBuilder.prototype.addBackground">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>addBackground
        <span class="apidocSignatureSpan">(background)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBackground = function (background) {
	var backgroundGetter = isFunction(background) ? background : function () {
		return background;
	};

	var pageBackground = backgroundGetter(this.writer.context().page + 1);

	if (pageBackground) {
		var pageSize = this.writer.context().getCurrentPage().pageSize;
		this.writer.beginUnbreakableBlock(pageSize.width, pageSize.height);
		this.processNode(this.docMeasure.measureDocument(pageBackground));
		this.writer.commitUnbreakableBlock(0, 0);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	docStructure = this.docMeasure.measureDocument(docStructure);

	this.writer = new PageElementWriter(
		new DocumentContext(this.pageSize, this.pageMargins), this.tracker);

	var _this = this;
	this.writer.context().tracker.startTracking(&#x27;pageAdded&#x27;, function () {
		_this.<span class="apidocCodeKeywordSpan">addBackground</span>(background);
	});

	this.addBackground(background);
	this.processNode(docStructure);
	this.addHeadersAndFooters(header, footer);
	/* jshint eqnull:true */
	if (watermark != null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.addDynamicRepeatable" id="apidoc.element.pdfmake.layoutBuilder.prototype.addDynamicRepeatable">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>addDynamicRepeatable
        <span class="apidocSignatureSpan">(nodeGetter, sizeFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addDynamicRepeatable = function (nodeGetter, sizeFunction) {
	var pages = this.writer.context().pages;

	for (var pageIndex = 0, l = pages.length; pageIndex &#x3c; l; pageIndex++) {
		this.writer.context().page = pageIndex;

		var node = nodeGetter(pageIndex + 1, l, this.writer.context().pages[pageIndex].pageSize);

		if (node) {
			var sizes = sizeFunction(this.writer.context().getCurrentPage().pageSize, this.pageMargins);
			this.writer.beginUnbreakableBlock(sizes.width, sizes.height);
			this.processNode(this.docMeasure.measureDocument(node));
			this.writer.commitUnbreakableBlock(sizes.x, sizes.y);
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.writer.beginUnbreakableBlock(pageSize.width, pageSize.height);
		this.processNode(this.docMeasure.measureDocument(pageBackground));
		this.writer.commitUnbreakableBlock(0, 0);
	}
};

LayoutBuilder.prototype.addStaticRepeatable = function (headerOrFooter, sizeFunction) {
	this.<span class="apidocCodeKeywordSpan">addDynamicRepeatable</span>(function () {
		return headerOrFooter;
	}, sizeFunction);
};

LayoutBuilder.prototype.addDynamicRepeatable = function (nodeGetter, sizeFunction) {
	var pages = this.writer.context().pages;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.addHeadersAndFooters" id="apidoc.element.pdfmake.layoutBuilder.prototype.addHeadersAndFooters">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>addHeadersAndFooters
        <span class="apidocSignatureSpan">(header, footer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addHeadersAndFooters = function (header, footer) {
	var headerSizeFct = function (pageSize, pageMargins) {
		return {
			x: 0,
			y: 0,
			width: pageSize.width,
			height: pageMargins.top
		};
	};

	var footerSizeFct = function (pageSize, pageMargins) {
		return {
			x: 0,
			y: pageSize.height - pageMargins.bottom,
			width: pageSize.width,
			height: pageMargins.bottom
		};
	};

	if (isFunction(header)) {
		this.addDynamicRepeatable(header, headerSizeFct);
	} else if (header) {
		this.addStaticRepeatable(header, headerSizeFct);
	}

	if (isFunction(footer)) {
		this.addDynamicRepeatable(footer, footerSizeFct);
	} else if (footer) {
		this.addStaticRepeatable(footer, footerSizeFct);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var _this = this;
	this.writer.context().tracker.startTracking(&#x27;pageAdded&#x27;, function () {
		_this.addBackground(background);
	});

	this.addBackground(background);
	this.processNode(docStructure);
	this.<span class="apidocCodeKeywordSpan">addHeadersAndFooters</span>(header, footer);
	/* jshint eqnull:true */
	if (watermark != null) {
		this.addWatermark(watermark, fontProvider, defaultStyle);
	}

	return {pages: this.writer.context().pages, linearNodeList: this.linearNodeList};
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.addStaticRepeatable" id="apidoc.element.pdfmake.layoutBuilder.prototype.addStaticRepeatable">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>addStaticRepeatable
        <span class="apidocSignatureSpan">(headerOrFooter, sizeFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addStaticRepeatable = function (headerOrFooter, sizeFunction) {
	this.addDynamicRepeatable(function () {
		return headerOrFooter;
	}, sizeFunction);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			height: pageMargins.bottom
		};
	};

	if (isFunction(header)) {
		this.addDynamicRepeatable(header, headerSizeFct);
	} else if (header) {
		this.<span class="apidocCodeKeywordSpan">addStaticRepeatable</span>(header, headerSizeFct);
	}

	if (isFunction(footer)) {
		this.addDynamicRepeatable(footer, footerSizeFct);
	} else if (footer) {
		this.addStaticRepeatable(footer, footerSizeFct);
	}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.addWatermark" id="apidoc.element.pdfmake.layoutBuilder.prototype.addWatermark">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>addWatermark
        <span class="apidocSignatureSpan">(watermark, fontProvider, defaultStyle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addWatermark = function (watermark, fontProvider, defaultStyle) {
	if (typeof watermark === &#x27;string&#x27;) {
		watermark = {&#x27;text&#x27;: watermark};
	}

	if (!watermark.text) { // empty watermark text
		return;
	}

	watermark.font = watermark.font || defaultStyle.font || &#x27;Roboto&#x27;;
	watermark.color = watermark.color || &#x27;black&#x27;;
	watermark.opacity = watermark.opacity || 0.6;
	watermark.bold = watermark.bold || false;
	watermark.italics = watermark.italics || false;

	var watermarkObject = {
		text: watermark.text,
		font: fontProvider.provideFont(watermark.font, watermark.bold, watermark.italics),
		size: getSize(this.pageSize, watermark, fontProvider),
		color: watermark.color,
		opacity: watermark.opacity
	};

	var pages = this.writer.context().pages;
	for (var i = 0, l = pages.length; i &#x3c; l; i++) {
		pages[i].watermark = watermarkObject;
	}

	function getSize(pageSize, watermark, fontProvider) {
		var width = pageSize.width;
		var height = pageSize.height;
		var targetWidth = Math.sqrt(width * width + height * height) * 0.8; /* page diagonal * sample factor */
		var textTools = new TextTools(fontProvider);
		var styleContextStack = new StyleContextStack(null, {font: watermark.font, bold: watermark.bold, italics: watermark.italics});
		var size;

		/**
		 * Binary search the best font size.
		 * Initial bounds [0, 1000]
		 * Break when range &#x3c; 1
		 */
		var a = 0;
		var b = 1000;
		var c = (a + b) / 2;
		while (Math.abs(a - b) &#x3e; 1) {
			styleContextStack.push({
				fontSize: c
			});
			size = textTools.sizeOfString(watermark.text, styleContextStack);
			if (size.width &#x3e; targetWidth) {
				b = c;
				c = (a + b) / 2;
			} else if (size.width &#x3c; targetWidth) {
				a = c;
				c = (a + b) / 2;
			}
			styleContextStack.pop();
		}
		/*
		 End binary search
		 */
		return {size: size, fontSize: c};
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	});

	this.addBackground(background);
	this.processNode(docStructure);
	this.addHeadersAndFooters(header, footer);
	/* jshint eqnull:true */
	if (watermark != null) {
		this.<span class="apidocCodeKeywordSpan">addWatermark</span>(watermark, fontProvider, defaultStyle);
	}

	return {pages: this.writer.context().pages, linearNodeList: this.linearNodeList};
};


LayoutBuilder.prototype.addBackground = function (background) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.buildNextLine" id="apidoc.element.pdfmake.layoutBuilder.prototype.buildNextLine">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>buildNextLine
        <span class="apidocSignatureSpan">(textNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildNextLine = function (textNode) {
	if (!textNode._inlines || textNode._inlines.length === 0) {
		return null;
	}

	var line = new Line(this.writer.context().availableWidth);

	while (textNode._inlines &#x26;&#x26; textNode._inlines.length &#x3e; 0 &#x26;&#x26; line.hasEnoughSpaceForInline(textNode._inlines[0])) {
		line.addInline(textNode._inlines.shift());
	}

	line.lastLineInParagraph = textNode._inlines.length === 0;

	return line;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}

	processor.endTable(this.writer);
};

// leafs (texts)
LayoutBuilder.prototype.processLeaf = function (node) {
	var line = this.<span class="apidocCodeKeywordSpan">buildNextLine</span>(node);
	var currentHeight = (line) ? line.getHeight() : 0;
	var maxHeight = node.maxHeight || -1;

	while (line &#x26;&#x26; (maxHeight === -1 || currentHeight &#x3c; maxHeight)) {
		var positions = this.writer.addLine(line);
		node.positions.push(positions);
		line = this.buildNextLine(node);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.layoutDocument" id="apidoc.element.pdfmake.layoutBuilder.prototype.layoutDocument">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>layoutDocument
        <span class="apidocSignatureSpan">(docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images, watermark, pageBreakBeforeFct )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">layoutDocument = function (docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images, watermark, pageBreakBeforeFct ) {

	function addPageBreaksIfNecessary(linearNodeList, pages) {

		if (!isFunction(pageBreakBeforeFct)) {
			return false;
		}

		linearNodeList = _.reject(linearNodeList, function (node) {
			return _.isEmpty(node.positions);
		});

		_.each(linearNodeList, function (node) {
			var nodeInfo = _.pick(node, [
				&#x27;id&#x27;, &#x27;text&#x27;, &#x27;ul&#x27;, &#x27;ol&#x27;, &#x27;table&#x27;, &#x27;image&#x27;, &#x27;qr&#x27;, &#x27;canvas&#x27;, &#x27;columns&#x27;,
				&#x27;headlineLevel&#x27;, &#x27;style&#x27;, &#x27;pageBreak&#x27;, &#x27;pageOrientation&#x27;,
				&#x27;width&#x27;, &#x27;height&#x27;
			]);
			nodeInfo.startPosition = _.first(node.positions);
			nodeInfo.pageNumbers = _.chain(node.positions).map(&#x27;pageNumber&#x27;).uniq().value();
			nodeInfo.pages = pages.length;
			nodeInfo.stack = _.isArray(node.stack);

			node.nodeInfo = nodeInfo;
		});

		return _.some(linearNodeList, function (node, index, followingNodeList) {
			if (node.pageBreak !== &#x27;before&#x27; &#x26;&#x26; !node.pageBreakCalculated) {
				node.pageBreakCalculated = true;
				var pageNumber = _.first(node.nodeInfo.pageNumbers);

				var followingNodesOnPage = _.chain(followingNodeList).drop(index + 1).filter(function (node0) {
					return _.includes(node0.nodeInfo.pageNumbers, pageNumber);
				}).value();

				var nodesOnNextPage = _.chain(followingNodeList).drop(index + 1).filter(function (node0) {
					return _.includes(node0.nodeInfo.pageNumbers, pageNumber + 1);
				}).value();

				var previousNodesOnPage = _.chain(followingNodeList).take(index).filter(function (node0) {
					return _.includes(node0.nodeInfo.pageNumbers, pageNumber);
				}).value();

				if (pageBreakBeforeFct(node.nodeInfo,
					_.map(followingNodesOnPage, &#x27;nodeInfo&#x27;),
					_.map(nodesOnNextPage, &#x27;nodeInfo&#x27;),
					_.map(previousNodesOnPage, &#x27;nodeInfo&#x27;))) {
					node.pageBreak = &#x27;before&#x27;;
					return true;
				}
			}
		});
	}

	this.docMeasure = new DocMeasure(fontProvider, styleDictionary, defaultStyle, this.imageMeasure, this.tableLayouts, images);


	function resetXYs(result) {
		_.each(result.linearNodeList, function (node) {
			node.resetXY();
		});
	}

	var result = this.tryLayoutDocument(docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images
, watermark);
	while (addPageBreaksIfNecessary(result.linearNodeList, result.pages)) {
		resetXYs(result);
		result = this.tryLayoutDocument(docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images,
watermark);
	}

	return result.pages;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.processCanvas" id="apidoc.element.pdfmake.layoutBuilder.prototype.processCanvas">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processCanvas
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processCanvas = function (node) {
	var height = node._minHeight;

	if (this.writer.context().availableHeight &#x3c; height) {
		// TODO: support for canvas larger than a page
		// TODO: support for other overflow methods

		this.writer.moveToNextPage();
	}

	node.canvas.forEach(function (vector) {
		var position = this.writer.addVector(vector);
		node.positions.push(position);
	}, this);

	this.writer.context().moveDown(height);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else if (node.table) {
			self.processTable(node);
		} else if (node.text !== undefined) {
			self.processLeaf(node);
		} else if (node.image) {
			self.processImage(node);
		} else if (node.canvas) {
			self.<span class="apidocCodeKeywordSpan">processCanvas</span>(node);
		} else if (node.qr) {
			self.processQr(node);
		} else if (!node._span) {
			throw &#x27;Unrecognized document structure: &#x27; + JSON.stringify(node, fontStringify);
		}

		if (absPosition || relPosition) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.processColumns" id="apidoc.element.pdfmake.layoutBuilder.prototype.processColumns">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processColumns
        <span class="apidocSignatureSpan">(columnNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processColumns = function (columnNode) {
	var columns = columnNode.columns;
	var availableWidth = this.writer.context().availableWidth;
	var gaps = gapArray(columnNode._gap);

	if (gaps) {
		availableWidth -= (gaps.length - 1) * columnNode._gap;
	}

	ColumnCalculator.buildColumnWidths(columns, availableWidth);
	var result = this.processRow(columns, columns, gaps);
	addAll(columnNode.positions, result.positions);


	function gapArray(gap) {
		if (!gap) {
			return null;
		}

		var gaps = [];
		gaps.push(0);

		for (var i = columns.length - 1; i &#x3e; 0; i--) {
			gaps.push(gap);
		}

		return gaps;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			self.writer.context().beginDetachedBlock();
			self.writer.context().moveTo((relPosition.x || 0) + self.writer.context().x, (relPosition.y || 0) + self.writer.context().y);
		}

		if (node.stack) {
			self.processVerticalContainer(node);
		} else if (node.columns) {
			self.<span class="apidocCodeKeywordSpan">processColumns</span>(node);
		} else if (node.ul) {
			self.processList(false, node);
		} else if (node.ol) {
			self.processList(true, node);
		} else if (node.table) {
			self.processTable(node);
		} else if (node.text !== undefined) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.processImage" id="apidoc.element.pdfmake.layoutBuilder.prototype.processImage">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processImage
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processImage = function (node) {
	var position = this.writer.addImage(node);
	node.positions.push(position);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else if (node.ol) {
			self.processList(true, node);
		} else if (node.table) {
			self.processTable(node);
		} else if (node.text !== undefined) {
			self.processLeaf(node);
		} else if (node.image) {
			self.<span class="apidocCodeKeywordSpan">processImage</span>(node);
		} else if (node.canvas) {
			self.processCanvas(node);
		} else if (node.qr) {
			self.processQr(node);
		} else if (!node._span) {
			throw &#x27;Unrecognized document structure: &#x27; + JSON.stringify(node, fontStringify);
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.processLeaf" id="apidoc.element.pdfmake.layoutBuilder.prototype.processLeaf">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processLeaf
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processLeaf = function (node) {
	var line = this.buildNextLine(node);
	var currentHeight = (line) ? line.getHeight() : 0;
	var maxHeight = node.maxHeight || -1;

	while (line &#x26;&#x26; (maxHeight === -1 || currentHeight &#x3c; maxHeight)) {
		var positions = this.writer.addLine(line);
		node.positions.push(positions);
		line = this.buildNextLine(node);
		if (line) {
			currentHeight += line.getHeight();
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else if (node.ul) {
			self.processList(false, node);
		} else if (node.ol) {
			self.processList(true, node);
		} else if (node.table) {
			self.processTable(node);
		} else if (node.text !== undefined) {
			self.<span class="apidocCodeKeywordSpan">processLeaf</span>(node);
		} else if (node.image) {
			self.processImage(node);
		} else if (node.canvas) {
			self.processCanvas(node);
		} else if (node.qr) {
			self.processQr(node);
		} else if (!node._span) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.processList" id="apidoc.element.pdfmake.layoutBuilder.prototype.processList">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processList
        <span class="apidocSignatureSpan">(orderedList, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processList = function (orderedList, node) {
	var self = this,
		items = orderedList ? node.ol : node.ul,
		gapSize = node._gapSize;

	this.writer.context().addMargin(gapSize.width);

	var nextMarker;
	this.tracker.auto(&#x27;lineAdded&#x27;, addMarkerToFirstLeaf, function () {
		items.forEach(function (item) {
			nextMarker = item.listMarker;
			self.processNode(item);
			addAll(node.positions, item.positions);
		});
	});

	this.writer.context().addMargin(-gapSize.width);

	function addMarkerToFirstLeaf(line) {
		// I&#x27;m not very happy with the way list processing is implemented
		// (both code and algorithm should be rethinked)
		if (nextMarker) {
			var marker = nextMarker;
			nextMarker = null;

			if (marker.canvas) {
				var vector = marker.canvas[0];

				offsetVector(vector, -marker._minWidth, 0);
				self.writer.addVector(vector);
			} else if (marker._inlines) {
				var markerLine = new Line(self.pageSize.width);
				markerLine.addInline(marker._inlines[0]);
				markerLine.x = -marker._minWidth;
				markerLine.y = line.getAscenderHeight() - markerLine.getAscenderHeight();
				self.writer.addLine(markerLine, true);
			}
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}

		if (node.stack) {
			self.processVerticalContainer(node);
		} else if (node.columns) {
			self.processColumns(node);
		} else if (node.ul) {
			self.<span class="apidocCodeKeywordSpan">processList</span>(false, node);
		} else if (node.ol) {
			self.processList(true, node);
		} else if (node.table) {
			self.processTable(node);
		} else if (node.text !== undefined) {
			self.processLeaf(node);
		} else if (node.image) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.processNode" id="apidoc.element.pdfmake.layoutBuilder.prototype.processNode">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processNode = function (node) {
	var self = this;

	this.linearNodeList.push(node);
	decorateNode(node);

	applyMargins(function () {
		var absPosition = node.absolutePosition;
		if (absPosition) {
			self.writer.context().beginDetachedBlock();
			self.writer.context().moveTo(absPosition.x || 0, absPosition.y || 0);
		}

		var relPosition = node.relativePosition;
		if (relPosition) {
			self.writer.context().beginDetachedBlock();
			self.writer.context().moveTo((relPosition.x || 0) + self.writer.context().x, (relPosition.y || 0) + self.writer.context().y);
		}

		if (node.stack) {
			self.processVerticalContainer(node);
		} else if (node.columns) {
			self.processColumns(node);
		} else if (node.ul) {
			self.processList(false, node);
		} else if (node.ol) {
			self.processList(true, node);
		} else if (node.table) {
			self.processTable(node);
		} else if (node.text !== undefined) {
			self.processLeaf(node);
		} else if (node.image) {
			self.processImage(node);
		} else if (node.canvas) {
			self.processCanvas(node);
		} else if (node.qr) {
			self.processQr(node);
		} else if (!node._span) {
			throw &#x27;Unrecognized document structure: &#x27; + JSON.stringify(node, fontStringify);
		}

		if (absPosition || relPosition) {
			self.writer.context().endDetachedBlock();
		}
	});

	function applyMargins(callback) {
		var margin = node._margin;

		if (node.pageBreak === &#x27;before&#x27;) {
			self.writer.moveToNextPage(node.pageOrientation);
		}

		if (margin) {
			self.writer.context().moveDown(margin[1]);
			self.writer.context().addMargin(margin[0], margin[2]);
		}

		callback();

		if (margin) {
			self.writer.context().addMargin(-margin[0], -margin[2]);
			self.writer.context().moveDown(margin[3]);
		}

		if (node.pageBreak === &#x27;after&#x27;) {
			self.writer.moveToNextPage(node.pageOrientation);
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	var _this = this;
	this.writer.context().tracker.startTracking(&#x27;pageAdded&#x27;, function () {
		_this.addBackground(background);
	});

	this.addBackground(background);
	this.<span class="apidocCodeKeywordSpan">processNode</span>(docStructure);
	this.addHeadersAndFooters(header, footer);
	/* jshint eqnull:true */
	if (watermark != null) {
		this.addWatermark(watermark, fontProvider, defaultStyle);
	}

	return {pages: this.writer.context().pages, linearNodeList: this.linearNodeList};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.processQr" id="apidoc.element.pdfmake.layoutBuilder.prototype.processQr">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processQr
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processQr = function (node) {
	var position = this.writer.addQr(node);
	node.positions.push(position);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else if (node.text !== undefined) {
			self.processLeaf(node);
		} else if (node.image) {
			self.processImage(node);
		} else if (node.canvas) {
			self.processCanvas(node);
		} else if (node.qr) {
			self.<span class="apidocCodeKeywordSpan">processQr</span>(node);
		} else if (!node._span) {
			throw &#x27;Unrecognized document structure: &#x27; + JSON.stringify(node, fontStringify);
		}

		if (absPosition || relPosition) {
			self.writer.context().endDetachedBlock();
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.processRow" id="apidoc.element.pdfmake.layoutBuilder.prototype.processRow">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processRow
        <span class="apidocSignatureSpan">(columns, widths, gaps, tableBody, tableRow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processRow = function (columns, widths, gaps, tableBody, tableRow) {
	var self = this;
	var pageBreaks = [], positions = [];

	this.tracker.auto(&#x27;pageChanged&#x27;, storePageBreakData, function () {
		widths = widths || columns;

		self.writer.context().beginColumnGroup();

		for (var i = 0, l = columns.length; i &#x3c; l; i++) {
			var column = columns[i];
			var width = widths[i]._calcWidth;
			var leftOffset = colLeftOffset(i);

			if (column.colSpan &#x26;&#x26; column.colSpan &#x3e; 1) {
				for (var j = 1; j &#x3c; column.colSpan; j++) {
					width += widths[++i]._calcWidth + gaps[i];
				}
			}

			self.writer.context().beginColumn(width, leftOffset, getEndingCell(column, i));
			if (!column._span) {
				self.processNode(column);
				addAll(positions, column.positions);
			} else if (column._columnEndingContext) {
				// row-span ending
				self.writer.context().markEnding(column);
			}
		}

		self.writer.context().completeColumnGroup();
	});

	return {pageBreaks: pageBreaks, positions: positions};

	function storePageBreakData(data) {
		var pageDesc;

		for (var i = 0, l = pageBreaks.length; i &#x3c; l; i++) {
			var desc = pageBreaks[i];
			if (desc.prevPage === data.prevPage) {
				pageDesc = desc;
				break;
			}
		}

		if (!pageDesc) {
			pageDesc = data;
			pageBreaks.push(pageDesc);
		}
		pageDesc.prevY = Math.max(pageDesc.prevY, data.prevY);
		pageDesc.y = Math.min(pageDesc.y, data.y);
	}

	function colLeftOffset(i) {
		if (gaps &#x26;&#x26; gaps.length &#x3e; i) {
			return gaps[i];
		}
		return 0;
	}

	function getEndingCell(column, columnIndex) {
		if (column.rowSpan &#x26;&#x26; column.rowSpan &#x3e; 1) {
			var endingRow = tableRow + column.rowSpan - 1;
			if (endingRow &#x3e;= tableBody.length) {
				throw &#x27;Row span for column &#x27; + columnIndex + &#x27; (with indexes starting from 0) exceeded row count&#x27;;
			}
			return tableBody[endingRow][columnIndex];
		}

		return null;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var gaps = gapArray(columnNode._gap);

	if (gaps) {
		availableWidth -= (gaps.length - 1) * columnNode._gap;
	}

	ColumnCalculator.buildColumnWidths(columns, availableWidth);
	var result = this.<span class="apidocCodeKeywordSpan">processRow</span>(columns, columns, gaps);
	addAll(columnNode.positions, result.positions);


	function gapArray(gap) {
		if (!gap) {
			return null;
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.processTable" id="apidoc.element.pdfmake.layoutBuilder.prototype.processTable">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processTable
        <span class="apidocSignatureSpan">(tableNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processTable = function (tableNode) {
	var processor = new TableProcessor(tableNode);

	processor.beginTable(this.writer);

	for (var i = 0, l = tableNode.table.body.length; i &#x3c; l; i++) {
		processor.beginRow(i, this.writer);

		var result = this.processRow(tableNode.table.body[i], tableNode.table.widths, tableNode._offsets.offsets, tableNode.table.body
, i);
		addAll(tableNode.positions, result.positions);

		processor.endRow(i, this.writer, result.pageBreaks);
	}

	processor.endTable(this.writer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else if (node.columns) {
			self.processColumns(node);
		} else if (node.ul) {
			self.processList(false, node);
		} else if (node.ol) {
			self.processList(true, node);
		} else if (node.table) {
			self.<span class="apidocCodeKeywordSpan">processTable</span>(node);
		} else if (node.text !== undefined) {
			self.processLeaf(node);
		} else if (node.image) {
			self.processImage(node);
		} else if (node.canvas) {
			self.processCanvas(node);
		} else if (node.qr) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.processVerticalContainer" id="apidoc.element.pdfmake.layoutBuilder.prototype.processVerticalContainer">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>processVerticalContainer
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processVerticalContainer = function (node) {
	var self = this;
	node.stack.forEach(function (item) {
		self.processNode(item);
		addAll(node.positions, item.positions);

		//TODO: paragraph gap
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		var relPosition = node.relativePosition;
		if (relPosition) {
			self.writer.context().beginDetachedBlock();
			self.writer.context().moveTo((relPosition.x || 0) + self.writer.context().x, (relPosition.y || 0) + self.writer.context().y);
		}

		if (node.stack) {
			self.<span class="apidocCodeKeywordSpan">processVerticalContainer</span>(node);
		} else if (node.columns) {
			self.processColumns(node);
		} else if (node.ul) {
			self.processList(false, node);
		} else if (node.ol) {
			self.processList(true, node);
		} else if (node.table) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.registerTableLayouts" id="apidoc.element.pdfmake.layoutBuilder.prototype.registerTableLayouts">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>registerTableLayouts
        <span class="apidocSignatureSpan">(tableLayouts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerTableLayouts = function (tableLayouts) {
	this.tableLayouts = pack(this.tableLayouts, tableLayouts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.layoutBuilder.prototype.tryLayoutDocument" id="apidoc.element.pdfmake.layoutBuilder.prototype.tryLayoutDocument">
        function <span class="apidocSignatureSpan">pdfmake.layoutBuilder.prototype.</span>tryLayoutDocument
        <span class="apidocSignatureSpan">(docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images, watermark, pageBreakBeforeFct )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryLayoutDocument = function (docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images, watermark, pageBreakBeforeFct ) {

	this.linearNodeList = [];
	docStructure = this.docMeasure.measureDocument(docStructure);

	this.writer = new PageElementWriter(
		new DocumentContext(this.pageSize, this.pageMargins), this.tracker);

	var _this = this;
	this.writer.context().tracker.startTracking(&#x27;pageAdded&#x27;, function () {
		_this.addBackground(background);
	});

	this.addBackground(background);
	this.processNode(docStructure);
	this.addHeadersAndFooters(header, footer);
	/* jshint eqnull:true */
	if (watermark != null) {
		this.addWatermark(watermark, fontProvider, defaultStyle);
	}

	return {pages: this.writer.context().pages, linearNodeList: this.linearNodeList};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	function resetXYs(result) {
		_.each(result.linearNodeList, function (node) {
			node.resetXY();
		});
	}

	var result = this.<span class="apidocCodeKeywordSpan">tryLayoutDocument</span>(docStructure, fontProvider, styleDictionary, defaultStyle
, background, header, footer, images, watermark);
	while (addPageBreaksIfNecessary(result.linearNodeList, result.pages)) {
		resetXYs(result);
		result = this.tryLayoutDocument(docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images,
watermark);
	}

	return result.pages;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.line" id="apidoc.module.pdfmake.line">module pdfmake.line</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.line.line" id="apidoc.element.pdfmake.line.line">
        function <span class="apidocSignatureSpan">pdfmake.</span>line
        <span class="apidocSignatureSpan">(maxWidth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Line(maxWidth) {
	this.maxWidth = maxWidth;
	this.leadingCut = 0;
	this.trailingCut = 0;
	this.inlineWidths = 0;
	this.inlines = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.line.prototype" id="apidoc.module.pdfmake.line.prototype">module pdfmake.line.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.line.prototype.addInline" id="apidoc.element.pdfmake.line.prototype.addInline">
        function <span class="apidocSignatureSpan">pdfmake.line.prototype.</span>addInline
        <span class="apidocSignatureSpan">(inline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addInline = function (inline) {
	if (this.inlines.length === 0) {
		this.leadingCut = inline.leadingCut || 0;
	}
	this.trailingCut = inline.trailingCut || 0;

	inline.x = this.inlineWidths - this.leadingCut;

	this.inlines.push(inline);
	this.inlineWidths += inline.width;

	if (inline.lineEnd) {
		this.newLineForced = true;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			if (marker.canvas) {
				var vector = marker.canvas[0];

				offsetVector(vector, -marker._minWidth, 0);
				self.writer.addVector(vector);
			} else if (marker._inlines) {
				var markerLine = new Line(self.pageSize.width);
				markerLine.<span class="apidocCodeKeywordSpan">addInline</span>(marker._inlines[0]);
				markerLine.x = -marker._minWidth;
				markerLine.y = line.getAscenderHeight() - markerLine.getAscenderHeight();
				self.writer.addLine(markerLine, true);
			}
		}
	}
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.line.prototype.getAscenderHeight" id="apidoc.element.pdfmake.line.prototype.getAscenderHeight">
        function <span class="apidocSignatureSpan">pdfmake.line.prototype.</span>getAscenderHeight
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAscenderHeight = function () {
	var y = 0;

	this.inlines.forEach(function (inline) {
		y = Math.max(y, inline.font.ascender / 1000 * inline.fontSize);
	});
	return y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

				offsetVector(vector, -marker._minWidth, 0);
				self.writer.addVector(vector);
			} else if (marker._inlines) {
				var markerLine = new Line(self.pageSize.width);
				markerLine.addInline(marker._inlines[0]);
				markerLine.x = -marker._minWidth;
				markerLine.y = line.<span class="apidocCodeKeywordSpan">getAscenderHeight</span>() - markerLine.getAscenderHeight();
				self.writer.addLine(markerLine, true);
			}
		}
	}
};

// tables
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.line.prototype.getHeight" id="apidoc.element.pdfmake.line.prototype.getHeight">
        function <span class="apidocSignatureSpan">pdfmake.line.prototype.</span>getHeight
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHeight = function () {
	var max = 0;

	this.inlines.forEach(function (item) {
		max = Math.max(max, item.height || 0);
	});

	return max;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		page.items.push(item);
	} else {
		page.items.splice(index, 0, item);
	}
}

ElementWriter.prototype.addLine = function (line, dontUpdateContextPosition, index) {
	var height = line.<span class="apidocCodeKeywordSpan">getHeight</span>();
	var context = this.context;
	var page = context.getCurrentPage(),
		position = this.getCurrentPositionOnPage();

	if (context.availableHeight &#x3c; height || !page) {
		return false;
	}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.line.prototype.getWidth" id="apidoc.element.pdfmake.line.prototype.getWidth">
        function <span class="apidocSignatureSpan">pdfmake.line.prototype.</span>getWidth
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getWidth = function () {
	return this.inlineWidths - this.leadingCut - this.trailingCut;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}

	return position;
};

ElementWriter.prototype.alignLine = function (line) {
	var width = this.context.availableWidth;
	var lineWidth = line.<span class="apidocCodeKeywordSpan">getWidth</span>();

	var alignment = line.inlines &#x26;&#x26; line.inlines.length &#x3e; 0 &#x26;&#x26; line.inlines[0].alignment;

	var offset = 0;
	switch (alignment) {
		case &#x27;right&#x27;:
			offset = width - lineWidth;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.line.prototype.hasEnoughSpaceForInline" id="apidoc.element.pdfmake.line.prototype.hasEnoughSpaceForInline">
        function <span class="apidocSignatureSpan">pdfmake.line.prototype.</span>hasEnoughSpaceForInline
        <span class="apidocSignatureSpan">(inline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasEnoughSpaceForInline = function (inline) {
	if (this.inlines.length === 0) {
		return true;
	}
	if (this.newLineForced) {
		return false;
	}

	return this.inlineWidths + inline.width - this.leadingCut - (inline.trailingCut || 0) &#x3c;= this.maxWidth;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
LayoutBuilder.prototype.buildNextLine = function (textNode) {
	if (!textNode._inlines || textNode._inlines.length === 0) {
		return null;
	}

	var line = new Line(this.writer.context().availableWidth);

	while (textNode._inlines &#x26;&#x26; textNode._inlines.length &#x3e; 0 &#x26;&#x26; line.<span class="apidocCodeKeywordSpan">hasEnoughSpaceForInline
</span>(textNode._inlines[0])) {
		line.addInline(textNode._inlines.shift());
	}

	line.lastLineInParagraph = textNode._inlines.length === 0;

	return line;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.pageElementWriter" id="apidoc.module.pdfmake.pageElementWriter">module pdfmake.pageElementWriter</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.pageElementWriter.pageElementWriter" id="apidoc.element.pdfmake.pageElementWriter.pageElementWriter">
        function <span class="apidocSignatureSpan">pdfmake.</span>pageElementWriter
        <span class="apidocSignatureSpan">(context, tracker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PageElementWriter(context, tracker) {
	this.transactionLevel = 0;
	this.repeatables = [];
	this.tracker = tracker;
	this.writer = new ElementWriter(context, tracker);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.pageElementWriter.prototype" id="apidoc.module.pdfmake.pageElementWriter.prototype">module pdfmake.pageElementWriter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.pageElementWriter.prototype.addFragment" id="apidoc.element.pdfmake.pageElementWriter.prototype.addFragment">
        function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>addFragment
        <span class="apidocSignatureSpan">(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addFragment = function (fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition) {
	if (!this.writer.addFragment(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition)) {
		this.moveToNextPage();
		this.writer.addFragment(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

PageElementWriter.prototype.addVector = function (vector, ignoreContextX, ignoreContextY, index) {
	return this.writer.addVector(vector, ignoreContextX, ignoreContextY, index);
};

PageElementWriter.prototype.addFragment = function (fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition) {
	if (!this.writer.<span class="apidocCodeKeywordSpan">addFragment</span>(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition
)) {
		this.moveToNextPage();
		this.writer.addFragment(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition);
	}
};

PageElementWriter.prototype.moveToNextPage = function (pageOrientation) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.pageElementWriter.prototype.addImage" id="apidoc.element.pdfmake.pageElementWriter.prototype.addImage">
        function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>addImage
        <span class="apidocSignatureSpan">(image, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addImage = function (image, index) {
	return fitOnPage(this, function (self) {
		return self.writer.addImage(image, index);
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	line.lastLineInParagraph = textNode._inlines.length === 0;

	return line;
};

// images
LayoutBuilder.prototype.processImage = function (node) {
	var position = this.writer.<span class="apidocCodeKeywordSpan">addImage</span>(node);
	node.positions.push(position);
};

LayoutBuilder.prototype.processCanvas = function (node) {
	var height = node._minHeight;

	if (this.writer.context().availableHeight &#x3c; height) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.pageElementWriter.prototype.addLine" id="apidoc.element.pdfmake.pageElementWriter.prototype.addLine">
        function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>addLine
        <span class="apidocSignatureSpan">(line, dontUpdateContextPosition, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addLine = function (line, dontUpdateContextPosition, index) {
	return fitOnPage(this, function (self) {
		return self.writer.addLine(line, dontUpdateContextPosition, index);
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				offsetVector(vector, -marker._minWidth, 0);
				self.writer.addVector(vector);
			} else if (marker._inlines) {
				var markerLine = new Line(self.pageSize.width);
				markerLine.addInline(marker._inlines[0]);
				markerLine.x = -marker._minWidth;
				markerLine.y = line.getAscenderHeight() - markerLine.getAscenderHeight();
				self.writer.<span class="apidocCodeKeywordSpan">addLine</span>(markerLine, true);
			}
		}
	}
};

// tables
LayoutBuilder.prototype.processTable = function (tableNode) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.pageElementWriter.prototype.addQr" id="apidoc.element.pdfmake.pageElementWriter.prototype.addQr">
        function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>addQr
        <span class="apidocSignatureSpan">(qr, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addQr = function (qr, index) {
	return fitOnPage(this, function (self) {
		return self.writer.addQr(qr, index);
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	return fitOnPage(this, function (self) {
		return self.writer.addImage(image, index);
	});
};

PageElementWriter.prototype.addQr = function (qr, index) {
	return fitOnPage(this, function (self) {
		return self.writer.<span class="apidocCodeKeywordSpan">addQr</span>(qr, index);
	});
};

PageElementWriter.prototype.addVector = function (vector, ignoreContextX, ignoreContextY, index) {
	return this.writer.addVector(vector, ignoreContextX, ignoreContextY, index);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.pageElementWriter.prototype.addVector" id="apidoc.element.pdfmake.pageElementWriter.prototype.addVector">
        function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>addVector
        <span class="apidocSignatureSpan">(vector, ignoreContextX, ignoreContextY, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addVector = function (vector, ignoreContextX, ignoreContextY, index) {
	return this.writer.addVector(vector, ignoreContextX, ignoreContextY, index);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	this.alignImage(qr);

	for (var i = 0, l = qr._canvas.length; i &#x3c; l; i++) {
		var vector = qr._canvas[i];
		vector.x += qr.x;
		vector.y += qr.y;
		this.<span class="apidocCodeKeywordSpan">addVector</span>(vector, true, true, index);
	}

	context.moveDown(qr._height);

	return position;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.pageElementWriter.prototype.beginUnbreakableBlock" id="apidoc.element.pdfmake.pageElementWriter.prototype.beginUnbreakableBlock">
        function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>beginUnbreakableBlock
        <span class="apidocSignatureSpan">(width, height)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beginUnbreakableBlock = function (width, height) {
	if (this.transactionLevel++ === 0) {
		this.originalX = this.writer.context.x;
		this.writer.pushContext(width, height);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		return background;
	};

	var pageBackground = backgroundGetter(this.writer.context().page + 1);

	if (pageBackground) {
		var pageSize = this.writer.context().getCurrentPage().pageSize;
		this.writer.<span class="apidocCodeKeywordSpan">beginUnbreakableBlock</span>(pageSize.width, pageSize.height);
		this.processNode(this.docMeasure.measureDocument(pageBackground));
		this.writer.commitUnbreakableBlock(0, 0);
	}
};

LayoutBuilder.prototype.addStaticRepeatable = function (headerOrFooter, sizeFunction) {
	this.addDynamicRepeatable(function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.pageElementWriter.prototype.commitUnbreakableBlock" id="apidoc.element.pdfmake.pageElementWriter.prototype.commitUnbreakableBlock">
        function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>commitUnbreakableBlock
        <span class="apidocSignatureSpan">(forcedX, forcedY)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commitUnbreakableBlock = function (forcedX, forcedY) {
	if (--this.transactionLevel === 0) {
		var unbreakableContext = this.writer.context;
		this.writer.popContext();

		var nbPages = unbreakableContext.pages.length;
		if (nbPages &#x3e; 0) {
			// no support for multi-page unbreakableBlocks
			var fragment = unbreakableContext.pages[0];
			fragment.xOffset = forcedX;
			fragment.yOffset = forcedY;

			//TODO: vectors can influence height in some situations
			if (nbPages &#x3e; 1) {
				// on out-of-context blocs (headers, footers, background) height should be the whole DocumentContext height
				if (forcedX !== undefined || forcedY !== undefined) {
					fragment.height = unbreakableContext.getCurrentPage().pageSize.height - unbreakableContext.pageMargins.top - unbreakableContext
.pageMargins.bottom;
				} else {
					fragment.height = this.writer.context.getCurrentPage().pageSize.height - this.writer.context.pageMargins.top - this.writer.
context.pageMargins.bottom;
					for (var i = 0, l = this.repeatables.length; i &#x3c; l; i++) {
						fragment.height -= this.repeatables[i].height;
					}
				}
			} else {
				fragment.height = unbreakableContext.y;
			}

			if (forcedX !== undefined || forcedY !== undefined) {
				this.writer.addFragment(fragment, true, true, true);
			} else {
				this.addFragment(fragment);
			}
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	var pageBackground = backgroundGetter(this.writer.context().page + 1);

	if (pageBackground) {
		var pageSize = this.writer.context().getCurrentPage().pageSize;
		this.writer.beginUnbreakableBlock(pageSize.width, pageSize.height);
		this.processNode(this.docMeasure.measureDocument(pageBackground));
		this.writer.<span class="apidocCodeKeywordSpan">commitUnbreakableBlock</span>(0, 0);
	}
};

LayoutBuilder.prototype.addStaticRepeatable = function (headerOrFooter, sizeFunction) {
	this.addDynamicRepeatable(function () {
		return headerOrFooter;
	}, sizeFunction);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.pageElementWriter.prototype.context" id="apidoc.element.pdfmake.pageElementWriter.prototype.context">
        function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>context
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">context = function () {
	return this.writer.context;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	this.linearNodeList = [];
	docStructure = this.docMeasure.measureDocument(docStructure);

	this.writer = new PageElementWriter(
		new DocumentContext(this.pageSize, this.pageMargins), this.tracker);

	var _this = this;
	this.writer.<span class="apidocCodeKeywordSpan">context</span>().tracker.startTracking(&#x27;pageAdded&#x27;, function () {
		_this.addBackground(background);
	});

	this.addBackground(background);
	this.processNode(docStructure);
	this.addHeadersAndFooters(header, footer);
	/* jshint eqnull:true */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.pageElementWriter.prototype.currentBlockToRepeatable" id="apidoc.element.pdfmake.pageElementWriter.prototype.currentBlockToRepeatable">
        function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>currentBlockToRepeatable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentBlockToRepeatable = function () {
	var unbreakableContext = this.writer.context;
	var rep = {items: []};

	unbreakableContext.pages[0].items.forEach(function (item) {
		rep.items.push(item);
	});

	rep.xOffset = this.originalX;

	//TODO: vectors can influence height in some situations
	rep.height = unbreakableContext.y;

	return rep;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			this.rowSpanData[i].rowSpan--;
		}
	}

	this.drawHorizontalLine(rowIndex + 1, writer);

	if (this.headerRows &#x26;&#x26; rowIndex === this.headerRows - 1) {
		this.headerRepeatable = writer.<span class="apidocCodeKeywordSpan">currentBlockToRepeatable</span>();
	}

	if (this.dontBreakRows) {
		writer.tracker.auto(&#x27;pageChanged&#x27;,
			function () {
				if (!self.headerRows &#x26;&#x26; self.layout.hLineWhenBroken !== false) {
					self.drawHorizontalLine(rowIndex, writer);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.pageElementWriter.prototype.moveToNextPage" id="apidoc.element.pdfmake.pageElementWriter.prototype.moveToNextPage">
        function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>moveToNextPage
        <span class="apidocSignatureSpan">(pageOrientation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveToNextPage = function (pageOrientation) {

	var nextPage = this.writer.context.moveToNextPage(pageOrientation);

	if (nextPage.newPageCreated) {
		this.repeatables.forEach(function (rep) {
			this.writer.addFragment(rep, true);
		}, this);
	} else {
		this.repeatables.forEach(function (rep) {
			this.writer.context.moveDown(rep.height);
		}, this);
	}

	this.writer.tracker.emit(&#x27;pageChanged&#x27;, {
		prevPage: nextPage.prevPage,
		prevY: nextPage.prevY,
		y: nextPage.y
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}
	});

	function applyMargins(callback) {
		var margin = node._margin;

		if (node.pageBreak === &#x27;before&#x27;) {
			self.writer.<span class="apidocCodeKeywordSpan">moveToNextPage</span>(node.pageOrientation);
		}

		if (margin) {
			self.writer.context().moveDown(margin[1]);
			self.writer.context().addMargin(margin[0], margin[2]);
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.pageElementWriter.prototype.popFromRepeatables" id="apidoc.element.pdfmake.pageElementWriter.prototype.popFromRepeatables">
        function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>popFromRepeatables
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">popFromRepeatables = function () {
	this.repeatables.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		lineWidth: width,
		lineColor: typeof this.layout.vLineColor === &#x27;function&#x27; ? this.layout.vLineColor(vLineIndex, this.tableNode) : this.
layout.vLineColor
	}, false, true);
};

TableProcessor.prototype.endTable = function (writer) {
	if (this.cleanUpRepeatables) {
		writer.<span class="apidocCodeKeywordSpan">popFromRepeatables</span>();
	}
};

TableProcessor.prototype.endRow = function (rowIndex, writer, pageBreaks) {
	var l, i;
	var self = this;
	writer.tracker.stopTracking(&#x27;pageChanged&#x27;, this.rowCallback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.pageElementWriter.prototype.pushToRepeatables" id="apidoc.element.pdfmake.pageElementWriter.prototype.pushToRepeatables">
        function <span class="apidocSignatureSpan">pdfmake.pageElementWriter.prototype.</span>pushToRepeatables
        <span class="apidocSignatureSpan">(rep)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushToRepeatables = function (rep) {
	this.repeatables.push(rep);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				writer.commitUnbreakableBlock();
			}
		);
	}

	if (this.headerRepeatable &#x26;&#x26; (rowIndex === (this.rowsWithoutPageBreak - 1) || rowIndex === this.tableNode.table.body.
length - 1)) {
		writer.commitUnbreakableBlock();
		writer.<span class="apidocCodeKeywordSpan">pushToRepeatables</span>(this.headerRepeatable);
		this.cleanUpRepeatables = true;
		this.headerRepeatable = null;
	}

	function getLineXs() {
		var result = [];
		var cols = 0;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.pdfMake" id="apidoc.module.pdfmake.pdfMake">module pdfmake.pdfMake</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.pdfMake.createPdf" id="apidoc.element.pdfmake.pdfMake.createPdf">
        function <span class="apidocSignatureSpan">pdfmake.pdfMake.</span>createPdf
        <span class="apidocSignatureSpan">(docDefinition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createPdf = function (docDefinition) {
		if (!canCreatePdf()) {
			throw &#x27;Your browser does not provide the level of support needed&#x27;;
		}
		return new Document(docDefinition, window.pdfMake.tableLayouts, window.pdfMake.fonts, window.pdfMake.vfs);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

or become pretty complex (having multi-level tables, images, lists, paragraphs, margins, styles etc...).

As soon as you have the document-definition-object, you&#x27;re ready to create and open/print/download the PDF:

```js
// open the PDF in a new window
pdfMake.<span class="apidocCodeKeywordSpan">createPdf</span>(docDefinition).open();

// print the PDF
pdfMake.createPdf(docDefinition).print();

// download the PDF
pdfMake.createPdf(docDefinition).download();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.qrEnc" id="apidoc.module.pdfmake.qrEnc">module pdfmake.qrEnc</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.qrEnc.measure" id="apidoc.element.pdfmake.qrEnc.measure">
        function <span class="apidocSignatureSpan">pdfmake.qrEnc.</span>measure
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function measure(node) {
	var cd = buildCanvas(node.qr, node);
	node._canvas = cd.canvas;
	node._width = node._height = node._minWidth = node._maxWidth = node._minHeight = node._maxHeight = cd.size;
	return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.styleContextStack" id="apidoc.module.pdfmake.styleContextStack">module pdfmake.styleContextStack</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.styleContextStack.styleContextStack" id="apidoc.element.pdfmake.styleContextStack.styleContextStack">
        function <span class="apidocSignatureSpan">pdfmake.</span>styleContextStack
        <span class="apidocSignatureSpan">(styleDictionary, defaultStyle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StyleContextStack(styleDictionary, defaultStyle) {
	this.defaultStyle = defaultStyle || {};
	this.styleDictionary = styleDictionary;
	this.styleOverrides = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.styleContextStack.prototype" id="apidoc.module.pdfmake.styleContextStack.prototype">module pdfmake.styleContextStack.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.styleContextStack.prototype.auto" id="apidoc.element.pdfmake.styleContextStack.prototype.auto">
        function <span class="apidocSignatureSpan">pdfmake.styleContextStack.prototype.</span>auto
        <span class="apidocSignatureSpan">(item, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">auto = function (item, callback) {
	var pushedItems = this.autopush(item);
	var result = callback();

	if (pushedItems &#x3e; 0) {
		this.pop(pushedItems);
	}

	return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	if (Object.keys(node).length === 0) {
		// A warning could be logged: console.warn(&#x27;pdfmake: Empty node, ignoring it&#x27;);
		node = {text: &#x27;&#x27;};
	}

	var self = this;

	return this.styleStack.<span class="apidocCodeKeywordSpan">auto</span>(node, function () {
		// TODO: refactor + rethink whether this is the proper way to handle margins
		node._margin = getNodeMargin(node);

		if (node.columns) {
			return extendMargins(self.measureColumns(node));
		} else if (node.stack) {
			return extendMargins(self.measureVerticalContainer(node));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.styleContextStack.prototype.autopush" id="apidoc.element.pdfmake.styleContextStack.prototype.autopush">
        function <span class="apidocSignatureSpan">pdfmake.styleContextStack.prototype.</span>autopush
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autopush = function (item) {
	if (typeof item === &#x27;string&#x27; || item instanceof String) {
		return 0;
	}

	var styleNames = [];

	if (item.style) {
		if (Array.isArray(item.style)) {
			styleNames = item.style;
		} else {
			styleNames = [item.style];
		}
	}

	for (var i = 0, l = styleNames.length; i &#x3c; l; i++) {
		this.push(styleNames[i]);
	}

	var styleOverrideObject = {};
	var pushSOO = false;

	[
		&#x27;font&#x27;,
		&#x27;fontSize&#x27;,
		&#x27;bold&#x27;,
		&#x27;italics&#x27;,
		&#x27;alignment&#x27;,
		&#x27;color&#x27;,
		&#x27;columnGap&#x27;,
		&#x27;fillColor&#x27;,
		&#x27;decoration&#x27;,
		&#x27;decorationStyle&#x27;,
		&#x27;decorationColor&#x27;,
		&#x27;background&#x27;,
		&#x27;lineHeight&#x27;,
		&#x27;noWrap&#x27;,
		&#x27;markerColor&#x27;
			//&#x27;tableCellPadding&#x27;
			// &#x27;cellBorder&#x27;,
			// &#x27;headerCellBorder&#x27;,
			// &#x27;oddRowCellBorder&#x27;,
			// &#x27;evenRowCellBorder&#x27;,
			// &#x27;tableBorder&#x27;
	].forEach(function (key) {
		if (item[key] !== undefined &#x26;&#x26; item[key] !== null) {
			styleOverrideObject[key] = item[key];
			pushSOO = true;
		}
	});

	if (pushSOO) {
		this.push(styleOverrideObject);
	}

	return styleNames.length + (pushSOO ? 1 : 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * executes callback and then pops elements back. Returns value returned by callback
 *
 * @param  {Object}   item - an object with optional style property and/or style overrides
 * @param  {Function} function to be called between autopush and pop
 * @return {Object} value returned by callback
 */
StyleContextStack.prototype.auto = function (item, callback) {
	var pushedItems = this.<span class="apidocCodeKeywordSpan">autopush</span>(item);
	var result = callback();

	if (pushedItems &#x3e; 0) {
		this.pop(pushedItems);
	}

	return result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.styleContextStack.prototype.clone" id="apidoc.element.pdfmake.styleContextStack.prototype.clone">
        function <span class="apidocSignatureSpan">pdfmake.styleContextStack.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
	var stack = new StyleContextStack(this.styleDictionary, this.defaultStyle);

	this.styleOverrides.forEach(function (item) {
		stack.styleOverrides.push(item);
	});

	return stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	return node;
};

DocMeasure.prototype.measureLeaf = function (node) {

	// Make sure style properties of the node itself are considered when building inlines.
	// We could also just pass [node] to buildInlines, but that fails for bullet points.
	var styleStack = this.styleStack.<span class="apidocCodeKeywordSpan">clone</span>();
	styleStack.push(node);

	var data = this.textTools.buildInlines(node.text, styleStack);

	node._inlines = data.items;
	node._minWidth = data.minWidth;
	node._maxWidth = data.maxWidth;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.styleContextStack.prototype.getProperty" id="apidoc.element.pdfmake.styleContextStack.prototype.getProperty">
        function <span class="apidocSignatureSpan">pdfmake.styleContextStack.prototype.</span>getProperty
        <span class="apidocSignatureSpan">(property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProperty = function (property) {
	if (this.styleOverrides) {
		for (var i = this.styleOverrides.length - 1; i &#x3e;= 0; i--) {
			var item = this.styleOverrides[i];

			if (typeof item === &#x27;string&#x27; || item instanceof String) {
				// named-style-override

				var style = this.styleDictionary[item];
				if (style &#x26;&#x26; style[property] !== null &#x26;&#x26; style[property] !== undefined) {
					return style[property];
				}
			} else {
				// style-overrides-object
				if (item[property] !== undefined &#x26;&#x26; item[property] !== null) {
					return item[property];
				}
			}
		}
	}

	return this.defaultStyle &#x26;&#x26; this.defaultStyle[property];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		node._width = node._minWidth = node._maxWidth = imageSize.width * factor;
		node._height = imageSize.height * factor;
	} else {
		node._width = node._minWidth = node._maxWidth = node.width || imageSize.width;
		node._height = node.height || (imageSize.height * node._width / imageSize.width);
	}

	node._alignment = this.styleStack.<span class="apidocCodeKeywordSpan">getProperty</span>(&#x27;alignment&#x27;);
	return node;
};

DocMeasure.prototype.measureLeaf = function (node) {

	// Make sure style properties of the node itself are considered when building inlines.
	// We could also just pass [node] to buildInlines, but that fails for bullet points.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.styleContextStack.prototype.pop" id="apidoc.element.pdfmake.styleContextStack.prototype.pop">
        function <span class="apidocSignatureSpan">pdfmake.styleContextStack.prototype.</span>pop
        <span class="apidocSignatureSpan">(howMany)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function (howMany) {
	howMany = howMany || 1;

	while (howMany-- &#x3e; 0) {
		this.styleOverrides.pop();
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		availableHeight: this.availableHeight,
		availableWidth: this.availableWidth,
		lastColumnWidth: this.lastColumnWidth
	};
};

DocumentContext.prototype.completeColumnGroup = function () {
	var saved = this.snapshots.<span class="apidocCodeKeywordSpan">pop</span>();

	this.calculateBottomMost(saved);

	this.endingCell = null;
	this.x = saved.x;
	this.y = saved.bottomMost.y;
	this.page = saved.bottomMost.page;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.styleContextStack.prototype.push" id="apidoc.element.pdfmake.styleContextStack.prototype.push">
        function <span class="apidocSignatureSpan">pdfmake.styleContextStack.prototype.</span>push
        <span class="apidocSignatureSpan">(styleNameOrOverride)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (styleNameOrOverride) {
	this.styleOverrides.push(styleNameOrOverride);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		starMaxMin = 0,
		starMaxMax = 0,
		fixedColumns = [],
		initial_availableWidth = availableWidth;

	columns.forEach(function (column) {
		if (isAutoColumn(column)) {
			autoColumns.<span class="apidocCodeKeywordSpan">push</span>(column);
			autoMin += column._minWidth;
			autoMax += column._maxWidth;
		} else if (isStarColumn(column)) {
			starColumns.push(column);
			starMaxMin = Math.max(starMaxMin, column._minWidth);
			starMaxMax = Math.max(starMaxMax, column._maxWidth);
		} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.tableProcessor" id="apidoc.module.pdfmake.tableProcessor">module pdfmake.tableProcessor</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.tableProcessor.tableProcessor" id="apidoc.element.pdfmake.tableProcessor.tableProcessor">
        function <span class="apidocSignatureSpan">pdfmake.</span>tableProcessor
        <span class="apidocSignatureSpan">(tableNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TableProcessor(tableNode) {
	this.tableNode = tableNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.tableProcessor.prototype" id="apidoc.module.pdfmake.tableProcessor.prototype">module pdfmake.tableProcessor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.tableProcessor.prototype.beginRow" id="apidoc.element.pdfmake.tableProcessor.prototype.beginRow">
        function <span class="apidocSignatureSpan">pdfmake.tableProcessor.prototype.</span>beginRow
        <span class="apidocSignatureSpan">(rowIndex, writer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beginRow = function (rowIndex, writer) {
	this.topLineWidth = this.layout.hLineWidth(rowIndex, this.tableNode);
	this.rowPaddingTop = this.layout.paddingTop(rowIndex, this.tableNode);
	this.bottomLineWidth = this.layout.hLineWidth(rowIndex + 1, this.tableNode);
	this.rowPaddingBottom = this.layout.paddingBottom(rowIndex, this.tableNode);

	this.rowCallback = this.onRowBreak(rowIndex, writer);
	writer.tracker.startTracking(&#x27;pageChanged&#x27;, this.rowCallback);
	if (this.dontBreakRows) {
		writer.beginUnbreakableBlock();
	}
	this.rowTopY = writer.context().y;
	this.reservedAtBottom = this.bottomLineWidth + this.rowPaddingBottom;

	writer.context().availableHeight -= this.reservedAtBottom;

	writer.context().moveDown(this.rowPaddingTop);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// tables
LayoutBuilder.prototype.processTable = function (tableNode) {
	var processor = new TableProcessor(tableNode);

	processor.beginTable(this.writer);

	for (var i = 0, l = tableNode.table.body.length; i &#x3c; l; i++) {
		processor.<span class="apidocCodeKeywordSpan">beginRow</span>(i, this.writer);

		var result = this.processRow(tableNode.table.body[i], tableNode.table.widths, tableNode._offsets.offsets, tableNode.table.body
, i);
		addAll(tableNode.positions, result.positions);

		processor.endRow(i, this.writer, result.pageBreaks);
	}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.tableProcessor.prototype.beginTable" id="apidoc.element.pdfmake.tableProcessor.prototype.beginTable">
        function <span class="apidocSignatureSpan">pdfmake.tableProcessor.prototype.</span>beginTable
        <span class="apidocSignatureSpan">(writer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beginTable = function (writer) {
	var tableNode;
	var availableWidth;
	var self = this;

	tableNode = this.tableNode;
	this.offsets = tableNode._offsets;
	this.layout = tableNode._layout;

	availableWidth = writer.context().availableWidth - this.offsets.total;
	ColumnCalculator.buildColumnWidths(tableNode.table.widths, availableWidth);

	this.tableWidth = tableNode._offsets.total + getTableInnerContentWidth();
	this.rowSpanData = prepareRowSpanData();
	this.cleanUpRepeatables = false;

	this.headerRows = tableNode.table.headerRows || 0;
	this.rowsWithoutPageBreak = this.headerRows + (tableNode.table.keepWithHeaderRows || 0);
	this.dontBreakRows = tableNode.table.dontBreakRows || false;

	if (this.rowsWithoutPageBreak) {
		writer.beginUnbreakableBlock();
	}

	// update the border properties of all cells before drawing any lines
	prepareCellBorders(this.tableNode.table.body);

	this.drawHorizontalLine(0, writer);

	function getTableInnerContentWidth() {
		var width = 0;

		tableNode.table.widths.forEach(function (w) {
			width += w._calcWidth;
		});

		return width;
	}

	function prepareRowSpanData() {
		var rsd = [];
		var x = 0;
		var lastWidth = 0;

		rsd.push({left: 0, rowSpan: 0});

		for (var i = 0, l = self.tableNode.table.body[0].length; i &#x3c; l; i++) {
			var paddings = self.layout.paddingLeft(i, self.tableNode) + self.layout.paddingRight(i, self.tableNode);
			var lBorder = self.layout.vLineWidth(i, self.tableNode);
			lastWidth = paddings + lBorder + self.tableNode.table.widths[i]._calcWidth;
			rsd[rsd.length - 1].width = lastWidth;
			x += lastWidth;
			rsd.push({left: x, rowSpan: 0, width: 0});
		}

		return rsd;
	}

	// Iterate through all cells. If the current cell is the start of a
	// rowSpan/colSpan, update the border property of the cells on its
	// bottom/right accordingly. This is needed since each iteration of the
	// line-drawing loops draws lines for a single cell, not for an entire
	// rowSpan/colSpan.
	function prepareCellBorders(body) {
		for (var rowIndex = 0; rowIndex &#x3c; body.length; rowIndex++) {
			var row = body[rowIndex];

			for (var colIndex = 0; colIndex &#x3c; row.length; colIndex++) {
				var cell = row[colIndex];

				if (cell.border) {
					var rowSpan = cell.rowSpan || 1;
					var colSpan = cell.colSpan || 1;

					for (var rowOffset = 0; rowOffset &#x3c; rowSpan; rowOffset++) {
						// set left border
						if (cell.border[0] !== undefined &#x26;&#x26; rowOffset &#x3e; 0) {
							setBorder(rowIndex + rowOffset, colIndex, 0, cell.border[0]);
						}

						// set right border
						if (cell.border[2] !== undefined) {
							setBorder(rowIndex + rowOffset, colIndex + colSpan - 1, 2, cell.border[2]);
						}
					}

					for (var colOffset = 0; colOffset &#x3c; colSpan; colOffset++) {
						// set top border
						if (cell.border[1] !== undefined &#x26;&#x26; colOffset &#x3e; 0) {
							setBorder(rowIndex, colIndex + colOffset, 1, cell.border[1]);
						}

						// set bottom border
						if (cell.border[3] !== undefined) {
							setBorder(rowIndex + rowSpan - 1, colIndex + colOffset, 3, cell.border[3]);
						}
					}
				}
			}
		}

		// helper function to set the border for a given cell
		function setBorder(rowIndex, colIndex, borderIndex, borderValue) {
			var cell = body[rowIndex][colIndex];
			cell.border = cell.border || {};
			cell.border[borderIndex] = borderValue;
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}
};

// tables
LayoutBuilder.prototype.processTable = function (tableNode) {
	var processor = new TableProcessor(tableNode);

	processor.<span class="apidocCodeKeywordSpan">beginTable</span>(this.writer);

	for (var i = 0, l = tableNode.table.body.length; i &#x3c; l; i++) {
		processor.beginRow(i, this.writer);

		var result = this.processRow(tableNode.table.body[i], tableNode.table.widths, tableNode._offsets.offsets, tableNode.table.body
, i);
		addAll(tableNode.positions, result.positions);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.tableProcessor.prototype.drawHorizontalLine" id="apidoc.element.pdfmake.tableProcessor.prototype.drawHorizontalLine">
        function <span class="apidocSignatureSpan">pdfmake.tableProcessor.prototype.</span>drawHorizontalLine
        <span class="apidocSignatureSpan">(lineIndex, writer, overrideY)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drawHorizontalLine = function (lineIndex, writer, overrideY) {
	var lineWidth = this.layout.hLineWidth(lineIndex, this.tableNode);
	if (lineWidth) {
		var offset = lineWidth / 2;
		var currentLine = null;
		var body = this.tableNode.table.body;

		for (var i = 0, l = this.rowSpanData.length; i &#x3c; l; i++) {
			var data = this.rowSpanData[i];
			var shouldDrawLine = !data.rowSpan;

			// draw only if the current cell requires a top border or the cell in the
			// row above requires a bottom border
			if (shouldDrawLine &#x26;&#x26; i &#x3c; l - 1) {
				var topBorder = false, bottomBorder = false;

				// the current cell
				if (lineIndex &#x3c; body.length) {
					var cell = body[lineIndex][i];
					topBorder = cell.border ? cell.border[1] : this.layout.defaultBorder;
				}

				// the cell in the row above
				if (lineIndex &#x3e; 0) {
					var cellAbove = body[lineIndex - 1][i];
					bottomBorder = cellAbove.border ? cellAbove.border[3] : this.layout.defaultBorder;
				}

				shouldDrawLine = topBorder || bottomBorder;
			}

			if (!currentLine &#x26;&#x26; shouldDrawLine) {
				currentLine = {left: data.left, width: 0};
			}

			if (shouldDrawLine) {
				currentLine.width += (data.width || 0);
			}

			var y = (overrideY || 0) + offset;

			if (!shouldDrawLine || i === l - 1) {
				if (currentLine &#x26;&#x26; currentLine.width) {
					writer.addVector({
						type: &#x27;line&#x27;,
						x1: currentLine.left,
						x2: currentLine.left + currentLine.width,
						y1: y,
						y2: y,
						lineWidth: lineWidth,
						lineColor: typeof this.layout.hLineColor === &#x27;function&#x27; ? this.layout.hLineColor(lineIndex, this.tableNode) : this.layout.
hLineColor
					}, false, overrideY);
					currentLine = null;
				}
			}
		}

		writer.context().moveDown(lineWidth);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	if (this.rowsWithoutPageBreak) {
		writer.beginUnbreakableBlock();
	}

	// update the border properties of all cells before drawing any lines
	prepareCellBorders(this.tableNode.table.body);

	this.<span class="apidocCodeKeywordSpan">drawHorizontalLine</span>(0, writer);

	function getTableInnerContentWidth() {
		var width = 0;

		tableNode.table.widths.forEach(function (w) {
			width += w._calcWidth;
		});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.tableProcessor.prototype.drawVerticalLine" id="apidoc.element.pdfmake.tableProcessor.prototype.drawVerticalLine">
        function <span class="apidocSignatureSpan">pdfmake.tableProcessor.prototype.</span>drawVerticalLine
        <span class="apidocSignatureSpan">(x, y0, y1, vLineIndex, writer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drawVerticalLine = function (x, y0, y1, vLineIndex, writer) {
	var width = this.layout.vLineWidth(vLineIndex, this.tableNode);
	if (width === 0) {
		return;
	}
	writer.addVector({
		type: &#x27;line&#x27;,
		x1: x + width / 2,
		x2: x + width / 2,
		y1: y0,
		y2: y1,
		lineWidth: width,
		lineColor: typeof this.layout.vLineColor === &#x27;function&#x27; ? this.layout.vLineColor(vLineIndex, this.tableNode) : this.layout.vLineColor
	}, false, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			// the cell from before column
			if (colIndex &#x3e; 0) {
				var cell = body[rowIndex][colIndex - 1];
				rightBorder = cell.border ? cell.border[2] : this.layout.defaultBorder;
			}

			if (leftBorder || rightBorder) {
				this.<span class="apidocCodeKeywordSpan">drawVerticalLine</span>(xs[i].x, y1 - hzLineOffset, y2 + this.bottomLineWidth, xs[i
].index, writer);
			}

			if (i &#x3c; l - 1) {
				var fillColor = body[rowIndex][colIndex].fillColor;
				if (!fillColor) {
					fillColor = typeof this.layout.fillColor === &#x27;function&#x27; ? this.layout.fillColor(rowIndex, this.tableNode) : this.
layout.fillColor;
				}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.tableProcessor.prototype.endRow" id="apidoc.element.pdfmake.tableProcessor.prototype.endRow">
        function <span class="apidocSignatureSpan">pdfmake.tableProcessor.prototype.</span>endRow
        <span class="apidocSignatureSpan">(rowIndex, writer, pageBreaks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endRow = function (rowIndex, writer, pageBreaks) {
	var l, i;
	var self = this;
	writer.tracker.stopTracking(&#x27;pageChanged&#x27;, this.rowCallback);
	writer.context().moveDown(this.layout.paddingBottom(rowIndex, this.tableNode));
	writer.context().availableHeight += this.reservedAtBottom;

	var endingPage = writer.context().page;
	var endingY = writer.context().y;

	var xs = getLineXs();

	var ys = [];

	var hasBreaks = pageBreaks &#x26;&#x26; pageBreaks.length &#x3e; 0;
	var body = this.tableNode.table.body;

	ys.push({
		y0: this.rowTopY,
		page: hasBreaks ? pageBreaks[0].prevPage : endingPage
	});

	if (hasBreaks) {
		for (i = 0, l = pageBreaks.length; i &#x3c; l; i++) {
			var pageBreak = pageBreaks[i];
			ys[ys.length - 1].y1 = pageBreak.prevY;

			ys.push({y0: pageBreak.y, page: pageBreak.prevPage + 1});
		}
	}

	ys[ys.length - 1].y1 = endingY;

	var skipOrphanePadding = (ys[0].y1 - ys[0].y0 === this.rowPaddingTop);
	for (var yi = (skipOrphanePadding ? 1 : 0), yl = ys.length; yi &#x3c; yl; yi++) {
		var willBreak = yi &#x3c; ys.length - 1;
		var rowBreakWithoutHeader = (yi &#x3e; 0 &#x26;&#x26; !this.headerRows);
		var hzLineOffset = rowBreakWithoutHeader ? 0 : this.topLineWidth;
		var y1 = ys[yi].y0;
		var y2 = ys[yi].y1;

		if (willBreak) {
			y2 = y2 + this.rowPaddingBottom;
		}

		if (writer.context().page != ys[yi].page) {
			writer.context().page = ys[yi].page;

			//TODO: buggy, availableHeight should be updated on every pageChanged event
			// TableProcessor should be pageChanged listener, instead of processRow
			this.reservedAtBottom = 0;
		}

		for (i = 0, l = xs.length; i &#x3c; l; i++) {
			var leftBorder = false, rightBorder = false;
			var colIndex = xs[i].index;

			// the current cell
			if (colIndex &#x3c; body[rowIndex].length) {
				var cell = body[rowIndex][colIndex];
				leftBorder = cell.border ? cell.border[0] : this.layout.defaultBorder;
			}

			// the cell from before column
			if (colIndex &#x3e; 0) {
				var cell = body[rowIndex][colIndex - 1];
				rightBorder = cell.border ? cell.border[2] : this.layout.defaultBorder;
			}

			if (leftBorder || rightBorder) {
				this.drawVerticalLine(xs[i].x, y1 - hzLineOffset, y2 + this.bottomLineWidth, xs[i].index, writer);
			}

			if (i &#x3c; l - 1) {
				var fillColor = body[rowIndex][colIndex].fillColor;
				if (!fillColor) {
					fillColor = typeof this.layout.fillColor === &#x27;function&#x27; ? this.layout.fillColor(rowIndex, this.tableNode) : this.layout.fillColor
;
				}
				if (fillColor) {
					var wBorder = (leftBorder || rightBorder) ? this.layout.vLineWidth(colIndex, this.tableNode) : 0;
					var xf = xs[i].x + wBorder;
					var yf = this.dontBreakRows ? y1 : y1 - hzLineOffset;
					writer.addVector({
						type: &#x27;rect&#x27;,
						x: xf,
						y: yf,
						w: xs[i + 1].x - xf,
						h: y2 + this.bottomLineWidth - yf,
						lineWidth: 0,
						color: fillColor
					}, false, true, 0);
				}
			}
		}

		if (willBreak &#x26;&#x26; this.layout.hLineWhenBroken !== false) {
			this.drawHorizontalLine(rowIndex + 1, writer, y2);
		}
		if (rowBreakWithoutHeader &#x26;&#x26; this.layout.hLineWhenBroken !== false) {
			this.drawHorizontalLine(rowIndex, writer, y1);
		}
	}

	writer.context().page = endingPage;
	writer.context().y = endingY;

	var row = this.tableNode.table.body[rowIndex];
	for (i = 0, l = row.length; i &#x3c; l; i++) {
		if (row[i].rowSpan) {
			this.rowSpanData[i].rowSpan = row[i].rowSpan;

			// fix colSpans
			if (row[i].colSpan &#x26;&#x26; row[i].colSpan &#x3e; 1) {
				for (var j = 1; j &#x3c; row[i].rowSpan; j++) {
					this.tableNode.table.body[rowIndex + j][i]._colSpan = row[i].colSpan;
				}
			}
		}

		if (this.rowSpanData[i].rowSpan &#x3e; 0) {
			this.rowSpanData[i].rowSpan--;
		}
	}

	this.drawHorizontalLine(rowIndex + 1, writer);

	if (this.headerRows &#x26;&#x26; rowIndex === this.headerRows - 1) {
		this.headerRepeatable = writer.currentBlockToRepeatable();
	}

	if (this.dontBreakRows) {
		writer.tracker.auto(&#x27;pageChanged&#x27;,
			function () {
				if (!self.headerRows &#x26;&#x26; self.layout.hLineWhenBroken !== false) {
					self.drawHorizontalL ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	for (var i = 0, l = tableNode.table.body.length; i &#x3c; l; i++) {
		processor.beginRow(i, this.writer);

		var result = this.processRow(tableNode.table.body[i], tableNode.table.widths, tableNode._offsets.offsets, tableNode.table.body
, i);
		addAll(tableNode.positions, result.positions);

		processor.<span class="apidocCodeKeywordSpan">endRow</span>(i, this.writer, result.pageBreaks);
	}

	processor.endTable(this.writer);
};

// leafs (texts)
LayoutBuilder.prototype.processLeaf = function (node) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.tableProcessor.prototype.endTable" id="apidoc.element.pdfmake.tableProcessor.prototype.endTable">
        function <span class="apidocSignatureSpan">pdfmake.tableProcessor.prototype.</span>endTable
        <span class="apidocSignatureSpan">(writer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endTable = function (writer) {
	if (this.cleanUpRepeatables) {
		writer.popFromRepeatables();
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		var result = this.processRow(tableNode.table.body[i], tableNode.table.widths, tableNode._offsets.offsets, tableNode.table.body
, i);
		addAll(tableNode.positions, result.positions);

		processor.endRow(i, this.writer, result.pageBreaks);
	}

	processor.<span class="apidocCodeKeywordSpan">endTable</span>(this.writer);
};

// leafs (texts)
LayoutBuilder.prototype.processLeaf = function (node) {
	var line = this.buildNextLine(node);
	var currentHeight = (line) ? line.getHeight() : 0;
	var maxHeight = node.maxHeight || -1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.tableProcessor.prototype.onRowBreak" id="apidoc.element.pdfmake.tableProcessor.prototype.onRowBreak">
        function <span class="apidocSignatureSpan">pdfmake.tableProcessor.prototype.</span>onRowBreak
        <span class="apidocSignatureSpan">(rowIndex, writer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onRowBreak = function (rowIndex, writer) {
	var self = this;
	return function () {
		//console.log(&#x27;moving by : &#x27;, topLineWidth, rowPaddingTop);
		var offset = self.rowPaddingTop + (!self.headerRows ? self.topLineWidth : 0);
		writer.context().moveDown(offset);
	};

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

TableProcessor.prototype.beginRow = function (rowIndex, writer) {
	this.topLineWidth = this.layout.hLineWidth(rowIndex, this.tableNode);
	this.rowPaddingTop = this.layout.paddingTop(rowIndex, this.tableNode);
	this.bottomLineWidth = this.layout.hLineWidth(rowIndex + 1, this.tableNode);
	this.rowPaddingBottom = this.layout.paddingBottom(rowIndex, this.tableNode);

	this.rowCallback = this.<span class="apidocCodeKeywordSpan">onRowBreak</span>(rowIndex, writer);
	writer.tracker.startTracking(&#x27;pageChanged&#x27;, this.rowCallback);
	if (this.dontBreakRows) {
		writer.beginUnbreakableBlock();
	}
	this.rowTopY = writer.context().y;
	this.reservedAtBottom = this.bottomLineWidth + this.rowPaddingBottom;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.textDecorator" id="apidoc.module.pdfmake.textDecorator">module pdfmake.textDecorator</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.textDecorator.drawBackground" id="apidoc.element.pdfmake.textDecorator.drawBackground">
        function <span class="apidocSignatureSpan">pdfmake.textDecorator.</span>drawBackground
        <span class="apidocSignatureSpan">(line, x, y, pdfKitDoc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function drawBackground(line, x, y, pdfKitDoc) {
	var height = line.getHeight();
	for (var i = 0, l = line.inlines.length; i &#x3c; l; i++) {
		var inline = line.inlines[i];
		if (inline.background) {
			pdfKitDoc.fillColor(inline.background)
				.rect(x + inline.x, y, inline.width, height)
				.fill();
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.textDecorator.drawDecorations" id="apidoc.element.pdfmake.textDecorator.drawDecorations">
        function <span class="apidocSignatureSpan">pdfmake.textDecorator.</span>drawDecorations
        <span class="apidocSignatureSpan">(line, x, y, pdfKitDoc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function drawDecorations(line, x, y, pdfKitDoc) {
	var groups = groupDecorations(line);
	for (var i = 0, l = groups.length; i &#x3c; l; i++) {
		drawDecoration(groups[i], x, y, pdfKitDoc);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.textTools" id="apidoc.module.pdfmake.textTools">module pdfmake.textTools</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.textTools.textTools" id="apidoc.element.pdfmake.textTools.textTools">
        function <span class="apidocSignatureSpan">pdfmake.</span>textTools
        <span class="apidocSignatureSpan">(fontProvider)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TextTools(fontProvider) {
	this.fontProvider = fontProvider;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.textTools.prototype" id="apidoc.module.pdfmake.textTools.prototype">module pdfmake.textTools.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.textTools.prototype.buildInlines" id="apidoc.element.pdfmake.textTools.prototype.buildInlines">
        function <span class="apidocSignatureSpan">pdfmake.textTools.prototype.</span>buildInlines
        <span class="apidocSignatureSpan">(textArray, styleContextStack)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildInlines = function (textArray, styleContextStack) {
	var measured = measure(this.fontProvider, textArray, styleContextStack);

	var minWidth = 0,
		maxWidth = 0,
		currentLineWidth;

	measured.forEach(function (inline) {
		minWidth = Math.max(minWidth, inline.width - inline.leadingCut - inline.trailingCut);

		if (!currentLineWidth) {
			currentLineWidth = {width: 0, leadingCut: inline.leadingCut, trailingCut: 0};
		}

		currentLineWidth.width += inline.width;
		currentLineWidth.trailingCut = inline.trailingCut;

		maxWidth = Math.max(maxWidth, getTrimmedWidth(currentLineWidth));

		if (inline.lineEnd) {
			currentLineWidth = null;
		}
	});

	if (getStyleProperty({}, styleContextStack, &#x27;noWrap&#x27;, false)) {
		minWidth = maxWidth;
	}

	return {
		items: measured,
		minWidth: minWidth,
		maxWidth: maxWidth
	};

	function getTrimmedWidth(item) {
		return Math.max(0, item.width - item.leadingCut - item.trailingCut);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
DocMeasure.prototype.measureLeaf = function (node) {

	// Make sure style properties of the node itself are considered when building inlines.
	// We could also just pass [node] to buildInlines, but that fails for bullet points.
	var styleStack = this.styleStack.clone();
	styleStack.push(node);

	var data = this.textTools.<span class="apidocCodeKeywordSpan">buildInlines</span>(node.text, styleStack);

	node._inlines = data.items;
	node._minWidth = data.minWidth;
	node._maxWidth = data.maxWidth;

	return node;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.textTools.prototype.sizeOfString" id="apidoc.element.pdfmake.textTools.prototype.sizeOfString">
        function <span class="apidocSignatureSpan">pdfmake.textTools.prototype.</span>sizeOfString
        <span class="apidocSignatureSpan">(text, styleContextStack)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sizeOfString = function (text, styleContextStack) {
	text = text ? text.toString().replace(&#x27;\t&#x27;, &#x27;    &#x27;) : &#x27;&#x27;;

	//TODO: refactor - extract from measure
	var fontName = getStyleProperty({}, styleContextStack, &#x27;font&#x27;, &#x27;Roboto&#x27;);
	var fontSize = getStyleProperty({}, styleContextStack, &#x27;fontSize&#x27;, 12);
	var bold = getStyleProperty({}, styleContextStack, &#x27;bold&#x27;, false);
	var italics = getStyleProperty({}, styleContextStack, &#x27;italics&#x27;, false);
	var lineHeight = getStyleProperty({}, styleContextStack, &#x27;lineHeight&#x27;, 1);

	var font = this.fontProvider.provideFont(fontName, bold, italics);

	return {
		width: font.widthOfString(text, fontSize),
		height: font.lineHeight(fontSize) * lineHeight,
		fontSize: fontSize,
		lineHeight: lineHeight,
		ascender: font.ascender / 1000 * fontSize,
		descender: font.descender / 1000 * fontSize
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		node._maxWidth = Math.max(node._maxWidth, items[i]._maxWidth);
	}

	return node;
};

DocMeasure.prototype.gapSizeForList = function () {
	return this.textTools.<span class="apidocCodeKeywordSpan">sizeOfString</span>(&#x27;9. &#x27;, this.styleStack);
};

DocMeasure.prototype.buildUnorderedMarker = function (styleStack, gapSize, type) {
	function buildDisc(gapSize, color) {
		// TODO: ascender-based calculations
		var radius = gapSize.fontSize / 6;
		return {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.traversalTracker" id="apidoc.module.pdfmake.traversalTracker">module pdfmake.traversalTracker</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.traversalTracker.traversalTracker" id="apidoc.element.pdfmake.traversalTracker.traversalTracker">
        function <span class="apidocSignatureSpan">pdfmake.</span>traversalTracker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TraversalTracker() {
	this.events = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdfmake.traversalTracker.prototype" id="apidoc.module.pdfmake.traversalTracker.prototype">module pdfmake.traversalTracker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pdfmake.traversalTracker.prototype.auto" id="apidoc.element.pdfmake.traversalTracker.prototype.auto">
        function <span class="apidocSignatureSpan">pdfmake.traversalTracker.prototype.</span>auto
        <span class="apidocSignatureSpan">(event, cb, innerBlock)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">auto = function (event, cb, innerBlock) {
	this.startTracking(event, cb);
	innerBlock();
	this.stopTracking(event, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	if (Object.keys(node).length === 0) {
		// A warning could be logged: console.warn(&#x27;pdfmake: Empty node, ignoring it&#x27;);
		node = {text: &#x27;&#x27;};
	}

	var self = this;

	return this.styleStack.<span class="apidocCodeKeywordSpan">auto</span>(node, function () {
		// TODO: refactor + rethink whether this is the proper way to handle margins
		node._margin = getNodeMargin(node);

		if (node.columns) {
			return extendMargins(self.measureColumns(node));
		} else if (node.stack) {
			return extendMargins(self.measureVerticalContainer(node));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.traversalTracker.prototype.emit" id="apidoc.element.pdfmake.traversalTracker.prototype.emit">
        function <span class="apidocSignatureSpan">pdfmake.traversalTracker.prototype.</span>emit
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (event) {
	var args = Array.prototype.slice.call(arguments, 1);

	var callbacks = this.events[event];

	if (callbacks) {
		callbacks.forEach(function (cb) {
			cb.apply(this, args);
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

DocumentContext.prototype.addPage = function (pageSize) {
	var page = {items: [], pageSize: pageSize};
	this.pages.push(page);
	this.page = this.pages.length - 1;
	this.initializePage();

	this.tracker.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;pageAdded&#x27;);

	return page;
};

DocumentContext.prototype.getCurrentPage = function () {
	if (this.page &#x3c; 0 || this.page &#x3e;= this.pages.length) {
		return null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.traversalTracker.prototype.startTracking" id="apidoc.element.pdfmake.traversalTracker.prototype.startTracking">
        function <span class="apidocSignatureSpan">pdfmake.traversalTracker.prototype.</span>startTracking
        <span class="apidocSignatureSpan">(event, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startTracking = function (event, cb) {
	var callbacks = (this.events[event] || (this.events[event] = []));

	if (callbacks.indexOf(cb) &#x3c; 0) {
		callbacks.push(cb);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	this.linearNodeList = [];
	docStructure = this.docMeasure.measureDocument(docStructure);

	this.writer = new PageElementWriter(
		new DocumentContext(this.pageSize, this.pageMargins), this.tracker);

	var _this = this;
	this.writer.context().tracker.<span class="apidocCodeKeywordSpan">startTracking</span>(&#x27;pageAdded&#x27;, function () {
		_this.addBackground(background);
	});

	this.addBackground(background);
	this.processNode(docStructure);
	this.addHeadersAndFooters(header, footer);
	/* jshint eqnull:true */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdfmake.traversalTracker.prototype.stopTracking" id="apidoc.element.pdfmake.traversalTracker.prototype.stopTracking">
        function <span class="apidocSignatureSpan">pdfmake.traversalTracker.prototype.</span>stopTracking
        <span class="apidocSignatureSpan">(event, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopTracking = function (event, cb) {
	var callbacks = this.events[event];

	if (callbacks) {
		var index = callbacks.indexOf(cb);
		if (index &#x3e;= 0) {
			callbacks.splice(index, 1);
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		writer.popFromRepeatables();
	}
};

TableProcessor.prototype.endRow = function (rowIndex, writer, pageBreaks) {
	var l, i;
	var self = this;
	writer.tracker.<span class="apidocCodeKeywordSpan">stopTracking</span>(&#x27;pageChanged&#x27;, this.rowCallback);
	writer.context().moveDown(this.layout.paddingBottom(rowIndex, this.tableNode));
	writer.context().availableHeight += this.reservedAtBottom;

	var endingPage = writer.context().page;
	var endingY = writer.context().y;

	var xs = getLineXs();
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
